!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine GetHyperCubeDims(ML,hcd)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Gets approximation interval for each DOF based on basis sizes in 
! bottom layer of ML-tree

      implicit none
      TYPE (MLtree), INTENT(IN) :: ML
      real*8, intent(inout) :: hcd(:,:)

!     Harmonic oscillator dimensions
      call GetHOdims(ML%gdim(1,:),hcd)

!     Other boundary conditions...
      !!!!

      end subroutine GetHyperCubeDims

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine GetHOdims(nbas,hcd)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Gets approximation interval for each DOF based on basis size and on
! harmonic oscillator boundary conditions

      implicit none
      integer, intent(in) :: nbas(:)
      real*8, intent(inout) :: hcd(:,:)
      integer :: i,ndof
      real*8  :: tmp

      ndof=SIZE(nbas)

!     Compute the position of the harmonic classical turning point for 
!     the energy of the highest basis function
      DO i=1,ndof
         tmp=sqrt(2*(nbas(i)-0.5))
         hcd(i,:)=(/-tmp,tmp/)
!         write(*,*) hcd(i,1),hcd(i,2)
      ENDDO

      end subroutine GetHOdims

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine ReadQFFHamiltonianOLD(id,ndim,ncub,nquart,divide,H,ML)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Reads Quartic Force Field Hamiltonian from files containing harmonic,
! cubic, and quartic constants

      implicit none
      TYPE (MLtree)       :: ML
      TYPE (Hamiltonian)  :: H
      integer, intent(in) :: ndim,ncub,nquart
      logical, intent(in) :: divide
      character(LEN=5), intent(in) :: id
      integer, allocatable :: modpowr(:,:)
      integer :: i,j,k,hterms,ndf
      integer :: F3(3),F4(4)
      real*8  :: omega,ftmp
      character(LEN=14) :: fname

      write(*,'(X,A,A/)') "--> Setting up Hamiltonian for ",id
      write(*,'(X,A,I0)') 'number of DOFs, quadratic terms   : ',ndim
      write(*,'(X,A,I0)') 'number of cubic anharmonic terms  : ',ncub
      write(*,'(X,A,I0)') 'number of quartic anharmonic terms: ',nquart

      IF (ML%nmode(1).ne.ndim) &
         call AbortWithError('Wrong # of DOFs for this Hamiltonian!')

!     Number of terms in Hamiltonian, before sorting
      hterms=2*ndim+ncub+nquart
      allocate(H%nterms(1),H%facs(hterms,1))
      allocate(H%dofs(hterms,ndim,1),H%ops(hterms,ndim,1))
      allocate(H%ndof(hterms,1),H%nop(hterms,1))
      H%nterms(1)=hterms

!     Read harmonic frequencies
      write(fname,'(A5,A5,A4)') 'omega',id,'.dat'
      open(44,status='old',file=fname)
      write(*,'(/X,A/)') 'Harmonic frequencies (original order)'
      k=1
      do i=1,ndim
         read(44,*) omega
         write(*,'(X,I3,X,f13.6)') i,omega
!        KEO
         H%facs(k,1)=0.5*omega
         H%dofs(k,1,1)=i
         H%ndof(k,1)=1
         H%ops(k,1,1)=-2 ! Flag for KEO
         H%nop(k,1)=1
         k=k+1
!        Harmonic potential
         H%facs(k,1)=0.5*omega
         H%dofs(k,1,1)=i
         H%ndof(k,1)=1
         H%ops(k,1,1)=2
         H%nop(k,1)=1
         k=k+1
      enddo
      close(44)

!     Read cubic anharmonic constants
      write(fname,'(A2,A5,A4)') 'f3',id,'.dat'
      open(45,status='old',file=fname)
      write(*,'(/X,A/)') 'Cubic anharmonic constants (original order)'
      do i=1,ncub
         read(45,*) (F3(j),j=1,3),ftmp
!        Convert F3 to list of modes and powers
         call DistribModePower(F3,modpowr)
         ndf=SIZE(modpowr,1)
         IF (divide) THEN  ! Account for degeneracy factors
            do j=1,ndf
               ftmp=ftmp/FACRL(modpowr(j,2))
            enddo
         ENDIF
         write(*,'(X,3(I3,X),f13.6)') (F3(j),j=1,3),ftmp
         H%facs(k,1)=ftmp
         H%ndof(k,1)=ndf
         H%nop(k,1)=1
         H%dofs(k,1:ndf,1)=modpowr(1:ndf,1)
         H%ops(k,1:ndf,1)=modpowr(1:ndf,2)
         k=k+1
         deallocate(modpowr)
      enddo
      close(45)

!     Read quartic anharmonic constants
      write(fname,'(A2,A5,A4)') 'f4',id,'.dat'
      open(46,status='old',file=fname)
      write(*,'(/X,A/)') 'Quartic anharmonic constants (original order)'
      do i=1,nquart
         read(46,*) (F4(j),j=1,4),ftmp
!        Convert F4 to list of modes and powers
         call DistribModePower(F4,modpowr)
         ndf=SIZE(modpowr,1)
         IF (divide) THEN  ! Account for degeneracy factors
            do j=1,ndf
               ftmp=ftmp/FACRL(modpowr(j,2))
            enddo
         ENDIF
         write(*,'(X,4(I3,X),f13.6)') (F4(j),j=1,4),ftmp
         H%facs(k,1)=ftmp
         H%ndof(k,1)=ndf
         H%nop(k,1)=1
         H%dofs(k,1:ndf,1)=modpowr(1:ndf,1)
         H%ops(k,1:ndf,1)=modpowr(1:ndf,2)
         k=k+1
         deallocate(modpowr)
      enddo
      write(*,*)
      close(46)

      end subroutine ReadQFFHamiltonianOLD

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine ReadQFFHamiltonianX(id,ndim,ncub,nquart,divide,H,ML)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Reads Quartic Force Field Hamiltonian from files containing harmonic,
! cubic, and quartic constants

      implicit none
      TYPE (MLtree)       :: ML
      TYPE (Hamiltonian)  :: H
      TYPE (CPvec), ALLOCATABLE  :: V(:)
      TYPE (CPvec) :: vtmp
      integer, intent(in) :: ndim,ncub,nquart
      logical, intent(in) :: divide
      character(LEN=5), intent(in) :: id
      integer, allocatable :: modpowr(:,:),nbastmp(:)
      integer :: i,j,k,hterms,ndf,gstart
      integer :: F3(3),F4(4)
      real*8  :: omega,ftmp
      character(LEN=14) :: fname

      write(*,'(/X,A,A/)') "--> Setting up Hamiltonian for ",id
      write(*,*) 'number of DOFs = ',ndim
      write(*,*) 'number of cubic anharmonic constants: ',ncub
      write(*,*) 'number of quartic anharmonic constants: ',nquart

      IF (ML%nmode(1).ne.ndim) &
         call AbortWithError('Wrong # of DOFs for this Hamiltonian!')

!     Number of terms in Hamiltonian, before sorting
!      hterms=2*ndim+ncub+nquart
!      allocate(H%nterms(1),H%facs(hterms,1))
!      allocate(H%dofs(hterms,ndim,1),H%ops(hterms,ndim,1))
!      allocate(H%ndof(hterms,1),H%nop(hterms,1))
!      H%nterms(1)=hterms      

!     Array for PES tensor
      ALLOCATE(V(3))

!     Read harmonic frequencies and store in CP-vec 'fquad'
      write(fname,'(A5,A5,A4)') 'omega',id,'.dat'
      open(44,status='old',file=fname)
      write(*,'(/X,A/)') 'Harmonic frequencies (original order)'

      ALLOCATE(nbastmp(2))
      nbastmp(:)=ndim
      call GetZeroCPvec(V(1),nbastmp)

      do i=1,ndim
         read(44,*) omega
         write(*,'(X,I3,X,f13.6)') i,omega

         call GetZeroCPvec(vtmp,nbastmp)
         vtmp%coef(1)=omega
         gstart=0
         DO j=1,SIZE(nbastmp)
            IF (j.gt.1) gstart=gstart+nbastmp(j-1)
            vtmp%base(gstart+i,1)=1.d0
         ENDDO
         call SUMVECVEC(V(1),1.d0,vtmp,1.d0)
         call PrintCPvec(vtmp)
         call FlushCPvec(vtmp)
      enddo
      close(44)
      DEALLOCATE(nbastmp)

!     Read cubic anharmonic constants and store in CP-vec 'fcub'
      write(fname,'(A2,A5,A4)') 'f3',id,'.dat'
      open(45,status='old',file=fname)
      write(*,'(/X,A/)') 'Cubic anharmonic constants (original order)'

      ALLOCATE(nbastmp(3))
      nbastmp(:)=ndim
      call GetZeroCPvec(V(2),nbastmp)

      do i=1,ncub
         read(45,*) (F3(j),j=1,3),ftmp
!        Convert F3 to list of modes and powers
         call DistribModePower(F3,modpowr)
         ndf=SIZE(modpowr,1)
         IF (divide) THEN  ! Account for degeneracy factors
            do j=1,ndf
               ftmp=ftmp/FACRL(modpowr(j,2))
            enddo
         ENDIF
         write(*,'(X,3(I3,X),f13.6)') (F3(j),j=1,3),ftmp

         call GetZeroCPvec(vtmp,nbastmp)
         vtmp%coef(1)=ftmp
         gstart=0
         DO j=1,SIZE(nbastmp)
            IF (j.gt.1) gstart=gstart+nbastmp(j-1)
            vtmp%base(gstart+F3(j),1)=1.d0
         ENDDO
         call SUMVECVEC(V(2),1.d0,vtmp,1.d0)
         call PrintCPvec(vtmp)
         call FlushCPvec(vtmp)

         deallocate(modpowr)
      enddo
      close(45)
      DEALLOCATE(nbastmp)

!     Read quartic anharmonic constants
      write(fname,'(A2,A5,A4)') 'f4',id,'.dat'
      open(46,status='old',file=fname)
      write(*,'(/X,A/)') 'Quartic anharmonic constants (original order)'

      ALLOCATE(nbastmp(4))
      nbastmp(:)=ndim
      call GetZeroCPvec(V(3),nbastmp)

      do i=1,nquart
         read(46,*) (F4(j),j=1,4),ftmp
!        Convert F4 to list of modes and powers
         call DistribModePower(F4,modpowr)
         ndf=SIZE(modpowr,1)
         IF (divide) THEN  ! Account for degeneracy factors
            do j=1,ndf
               ftmp=ftmp/FACRL(modpowr(j,2))
            enddo
         ENDIF
         write(*,'(X,4(I3,X),f13.6)') (F4(j),j=1,4),ftmp

         call GetZeroCPvec(vtmp,nbastmp)
         vtmp%coef(1)=ftmp
         gstart=0
         DO j=1,SIZE(nbastmp)
            IF (j.gt.1) gstart=gstart+nbastmp(j-1)
            vtmp%base(gstart+F4(j),1)=1.d0
         ENDDO
         call SUMVECVEC(V(3),1.d0,vtmp,1.d0)
         call PrintCPvec(vtmp)
         call FlushCPvec(vtmp)

         deallocate(modpowr)
      enddo
      write(*,*)
      close(46)
      DEALLOCATE(nbastmp)

      call RotateHamil(V)
      DEALLOCATE(V)

      end subroutine ReadQFFHamiltonianX

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine GetFFHamiltonian(id,ndof,ncoef,divide,H,ML)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Reads Quartic Force Field Hamiltonian from files containing harmonic,
! cubic, quartic, etc. constants

      implicit none
      TYPE (MLtree)       :: ML
      TYPE (Hamiltonian)  :: H
      TYPE (CPvec), ALLOCATABLE  :: V(:)
      TYPE (Configs) :: w
      integer, intent(in) :: ndof,ncoef(:)
      logical, intent(in) :: divide
      character(LEN=5), intent(in) :: id
      integer, allocatable :: nbas(:),modpowr(:,:)
      real*8, allocatable  :: freqs(:)
      integer :: i,j,k,l,u,ndf,ncoup,hterms
      character(LEN=20) :: fname
      character*64 :: frmt
      logical :: rotate=.FALSE.

      ncoup=SIZE(ncoef)

      write(*,'(/X,A,A/)') "--> Setting up Hamiltonian for ",id
      write(*,'(X,A,X,I0)') 'Number of degrees of freedom:',ndof
      write(*,'(X,A,X,I0)') 'Number of harmonic constants:',ncoef(1)
      DO k=2,ncoup
         write(*,'(X,2(A,X,I0))') &
         'Number of anharmonic constants of order',k+1,':',ncoef(k)
      ENDDO

      IF (ML%nmode(1).ne.ndof) &
         call AbortWithError('Wrong # of DOFs for this Hamiltonian!')

!     Array for PES tensor
      ALLOCATE(V(ncoup),freqs(ndof))

!     Read potential constants and store in CP-vec 'V'
      DO k=1,ncoup
         write(*,'(/X,2A,I0/)') 'Potential constants (.dat file',&
                                ' ordering), order: ',k+1

         ALLOCATE(nbas(k+1))
         nbas(:)=ndof
         call NewConfigs(w,nbas,ncoef(k))

         write(fname,'(A5,I0,A5,A4)') 'pes/f',k+1,id,'.dat'
         u=LookForFreeUnit()
         open(u,status='old',file=fname)

         DO i=1,ncoef(k)
            read(u,*) (w%qns(i,j),j=1,k+1),w%coef(i)

!           Store the (omega_j)^(1/2) values for scaling
            IF (k.eq.1 .and. w%qns(i,1).eq.w%qns(i,2)) THEN
               freqs(w%qns(i,1))=sqrt(w%coef(i))
            ENDIF
         ENDDO
         close(u)

         call PrintConfigs(w)

!        Divide by degeneracy factors (if necessary) and scale
!        constants by the (omega_j)^(1/2) values
         DO i=1,ncoef(k)
            call DistribModePower(w%qns(i,:),modpowr)
            ndf=SIZE(modpowr,1)

!           Account for degeneracy factors. Always divide the quadratic
!           constants by 2 since they are given as harmonic frequencies
            IF (divide.or.k.eq.1) THEN
               do j=1,ndf
                  w%coef(i)=w%coef(i)/FACRL(modpowr(j,2))
               enddo
            ENDIF
            DO j=1,k+1
               w%coef(i)=w%coef(i)*freqs(w%qns(i,j))
            ENDDO
         ENDDO
!        Convert: configuration list --> CP-format
         call Config2CP(V(k),w)
         call FlushConfigs(w)
         DEALLOCATE(nbas)
      ENDDO

!     Optimize the PES by coordinate transformation
      IF (rotate) call RotateHamil(V)

!!!   Store the PES in Hamiltonian type

!     Count the number of terms in H. In addition to the PES, there are
!     ndof terms that must be counted for the KEO.
      hterms=ndof
      DO k=1,ncoup
         hterms=hterms+SIZE(V(k)%coef)
      ENDDO
      allocate(H%nterms(1),H%facs(hterms,1))
      allocate(H%dofs(hterms,ndof,1),H%ops(hterms,ndof,1))
      allocate(H%ndof(hterms,1),H%nop(hterms,1))
      H%nterms(1)=hterms

      l=1
      DO k=1,ncoup
         IF (rotate) &
         write(*,'(/X,A,I0/)') 'Rotated constants, order: ',k+1

!        Convert: CP-format --> configuration list
         call CP2Config(V(k),w)

!        Extract (omega_j)^(1/2) values for scaling
         IF (k.eq.1) THEN
            DO i=1,SIZE(w%coef)
               IF (w%qns(i,1).eq.w%qns(i,2)) THEN
                  freqs(w%qns(i,1))=(2.d0*w%coef(i))**0.25d0
               ENDIF
            ENDDO
         ENDIF

         DO i=1,SIZE(w%coef)
!           Scale constant by (omega_j)^(1/2) values
!           and convert qns to list of modes and powers
            DO j=1,k+1
               w%coef(i)=w%coef(i)/freqs(w%qns(i,j))
            ENDDO
            call DistribModePower(w%qns(i,:),modpowr)
            ndf=SIZE(modpowr,1)

!           KEO
            IF (k.eq.1 .and. ndf.eq.1) THEN
               H%facs(l,1)=w%coef(i)
               H%ndof(l,1)=1
               H%nop(l,1)=1
               H%dofs(l,1,1)=modpowr(1,1)
               H%ops(l,1,1)=-2 ! Flag for KEO
               l=l+1
            ENDIF

            H%facs(l,1)=w%coef(i)
            H%ndof(l,1)=ndf
            H%nop(l,1)=1
            H%dofs(l,1:ndf,1)=modpowr(1:ndf,1)
            H%ops(l,1:ndf,1)=modpowr(1:ndf,2)
            l=l+1
            deallocate(modpowr)
         ENDDO
         IF (rotate) call PrintConfigs(w)
         call FlushConfigs(w)
      ENDDO

      DEALLOCATE(V,freqs)

!      call AbortWithError('done rotating')

      end subroutine GetFFHamiltonian

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine PES2CP(H)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Builds CP-format representation of a PES stored in type 'Hamiltonian'

      implicit none
      TYPE (Hamiltonian), INTENT(IN) :: H
      TYPE (CPvec) :: V,w
      integer, allocatable :: nbastmp(:)
      integer :: ndof,nop,nrk,ndf,i,j,k,thedof,theop
      integer :: newrk
      real*8, parameter :: redtol=1.d-12

!     Parameters
      ndof=SIZE(H%dofs,2)
      nop=H%nterms(1)
      nrk=nop-ndof
      ALLOCATE(nbastmp(ndof))

!     Determine the number of operators (powers of q_i ) for each DOF 
!     in the PES (add 1 at the end for the identity, q_i^0, that is).
!     Kinetic energy operators are not included here
      nbastmp=0
      DO k=1,nop
         ndf=H%ndof(k,1)
         DO j=1,ndf
            thedof=H%dofs(k,j,1)
            theop=H%ops(k,j,1)
            IF (theop.gt.nbastmp(thedof)) nbastmp(thedof)=theop
         ENDDO
      ENDDO
!     Add 1 since the identity is also to be included
      nbastmp=nbastmp+1

!     Construct the CP vector
      CALL NewCPvec(V,nbastmp,nrk)
      V%base=1.d-16

!     Recycle the nbastmp array to hold the index for where in the base
!     each DOF starts. Then initialize the base to 1.0 in the first
!     position for each DOF, which corresponds to the identity operation
      nbastmp(1)=1
      V%base(1,:)=1.d0
      DO j=2,ndof
         nbastmp(j)=nbastmp(j-1)+V%nbas(j)
         V%base(nbastmp(j),:)=1.d0
      ENDDO

!     Now loop over the potential terms and modify the CP-vector for
!     each accordingly
      i=1
      DO k=1,nop
         ndf=H%ndof(k,1)
!        Skip kinetic energy terms
         IF (.not.(H%ndof(k,1).eq.1 .and. H%ops(k,1,1).lt.0)) THEN
            ndf=H%ndof(k,1)
            DO j=1,ndf
               thedof=H%dofs(k,j,1)
               theop=H%ops(k,j,1)
!              Replace the 1.0 coef for the identity with a 1.0 coef
!              for the power of q
               V%base(nbastmp(thedof)+theop,i)=1.d0
               V%base(nbastmp(thedof),i)=1.d-16
            ENDDO
            V%coef(i)=abs(H%facs(k,1))
!           Change sign of base to keep coef positive
            IF (H%facs(k,1).lt.0.d0) THEN
               V%base(1:V%nbas(1),i)=-V%base(1:V%nbas(1),i)
            ENDIF
            i=i+1
         ENDIF
      ENDDO
      write(*,*) 'Original PES vector (in small chunks)'
      i=1
      k=5
      DO
         write(*,*) 'PES vec, rank',i,' through ',k
         CALL NewCPvec(w,V%nbas,k-i+1)
         w%coef(:)=v%coef(i:k)
         w%base(:,:)=v%base(:,i:k)
         CALL PrintCPvec(w)
         CALL FlushCPvec(w)
         i=i+5
         k=k+5
         IF (k.gt.SIZE(V%coef)) k=SIZE(V%coef)
         IF (i.gt.SIZE(V%coef)) EXIT
      ENDDO
      write(*,*)

      CALL reduc_bysorting(V,SIZE(V%coef))
      write(*,'(2(A,I0))')'Sorting reduced rank: ',nrk,' --> ',SIZE(V%coef)
      newrk=30 !SIZE(V%coef)
      write(*,*) 'Additional reduction to rank ',newrk
      CALL SetReductionParameters(newrk,500,1.d-12,.TRUE.,'SVD','ALS')
      CALL reduc(V)
      CALL NORMBASE(V)
      CALL ordre(V)

      write(*,*)
      write(*,*) 'CP-PES (in small chunks)'
      IF (SIZE(V%coef).le.5) THEN
         call PrintCPvec(V)
      ELSE
         i=1
         k=5
         DO
            write(*,*) 'PES vec, rank',i,' through ',k
            CALL NewCPvec(w,V%nbas,k-i+1)
            w%coef(:)=v%coef(i:k)
            w%base(:,:)=v%base(:,i:k)
            CALL PrintCPvec(w)
            CALL FlushCPvec(w)
            i=i+5
            k=k+5
            IF (k.gt.SIZE(V%coef)) k=SIZE(V%coef)
            IF (i.gt.SIZE(V%coef)) EXIT
         ENDDO
      ENDIF

      CALL FlushCPvec(V)
      DEALLOCATE(nbastmp)

      CALL AbortWithError('Done')

      end subroutine PES2CP

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine SolveBPsimpleCP(B,A,X,R,G,csp)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Computes the vector solving the LS_tau problem:
! Minimize ||Ax - b||_2 with respect to x, subject to ||x||_1 <= tau
! This version uses the discrete cosine transform for the matrix
! multiplication step. See Algorithm 1 in:
! van der Berg and Friedlander, SIAM J. Sci. Comput. 31 (2008) 890-912

      implicit none
      TYPE (CSpar), INTENT(IN)    :: csp
      TYPE (CPvec), INTENT(IN)    :: B,A    ! Transformation matrix
      TYPE (CPvec), INTENT(OUT)   :: X,R,G  ! Solution, Gradient
      TYPE (CPvec)   :: Xnew,Rnew,Gnew
      TYPE (Configs) :: Ct
      real*8, parameter    :: redtol=1.d-12
      real*8  :: tau,rnorm,bnorm2
      real*8  :: sigma,bptol,lstol,opttol,dectol,f,fnew,ftmp
      real*8  :: aax,bx,cx,step,l22
      integer :: iter,maxit,maxLineErrors,nals
      integer :: rkx,i
      character(len=72) :: messg

      write(*,'(/A/)') '*** BP_simple CP ***'

!     Set parameters from input file
      rkx=csp%pesrank
      nals=csp%nals
      maxit=csp%ncycle
      maxLineErrors=csp%maxlnerr
      sigma=csp%sigma
      bptol=csp%bptol
      lstol=csp%lstol
      opttol=csp%opttol
      dectol=csp%dectol

      call SetReductionParameters(rkx,nals,redtol,.FALSE.,csp%red2D,&
                                  csp%redND)

!     Initial values
      bnorm2=PRODVV(B)
      tau=0.d0
      iter=0

!     Initialize zero solution vector for BP-sigma
      call GetZeroCPvec(X,B%nbas)

!     Initialize residual objective function value
      call CopyWtoV(R,B)
      bnorm2=PRODVV(B)
      rnorm=sqrt(bnorm2)
      fnew=0.5*bnorm2
      f=fnew

!      call reduc(R)
!      call ExtractTopConfigs(R,Ct,rkx)
!      call FlushCPvec(R)
!      call TrimZeroConfigs(Ct,sigma)
!      call Config2CP(R,Ct)
!      call FlushConfigs(Ct)

!     Calculate the gradient: G = -A^T*R
      call CPMatVecProd(A,R,G,.TRUE.)
      call VecSignChange(G,1,SIZE(G%coef))

!     Early exit if the norm of the residual is less than sigma
!     (in which case the initial zero vector is already feasible)
      IF (rnorm.lt.sigma) RETURN

      DO
         iter=iter+1

         IF (iter.ge.maxit .or. sqrt(2*fnew).lt.sigma) EXIT

!        First save objective function value before updating
         f=fnew

!        NR line search
!         call PESCPbracket(B,Rnew,X,G,A,Xnew,rkx,bnorm2,sigma,f,aax,bx,cx)
!         call PESCPminimize(B,Rnew,X,G,A,Xnew,rkx,bnorm2,sigma,&
!                               aax,bx,cx,step,ftmp)

!        Reduce the rank of Xnew
!         call reduc(Xnew)
         call ExtractTopConfigs(Xnew,Ct,rkx)
         call FlushCPvec(Xnew)
         call TrimZeroConfigs(Ct,sigma)
         call Config2CP(Xnew,Ct)
         call FlushConfigs(Ct)

!        Calculate the residual and objective function value
!        for the Xnew obtained after reduction
         call CPMatVecProd(A,Xnew,Rnew,.FALSE.)
         l22=bnorm2-2*PRODVV(B,Rnew)+PRODVV(Rnew)
         call SUMVECVEC(Rnew,-1.d0,B,1.d0)
!         call reduc(Rnew)
!         call ExtractTopConfigs(Rnew,Ct,rkx)
!         call FlushCPvec(Rnew)
!         call TrimZeroConfigs(Ct,sigma)
!         call Config2CP(Rnew,Ct)
!         call FlushConfigs(Ct)

         IF (0.5*l22.lt.f) THEN
            fnew=0.5*l22

            write(*,*) iter,sqrt(2*ftmp),sqrt(l22),SIZE(Xnew%coef)

!           Update the gradient
            call CPMatVecProd(A,R,Gnew,.TRUE.)
            call VecSignChange(Gnew,1,SIZE(Gnew%coef))

!           Replace X <-- Xnew, R <-- Rnew, G <-- Gnew
            call ReplaceVwithW(X,Xnew)
            call ReplaceVwithW(G,Gnew)
            call ReplaceVwithW(R,Rnew)

!        Do not update if residual gets worse
         ELSE
            write(*,*) iter
            call FlushCPvec(Xnew)
            call FlushCPvec(Rnew)

!           Recompute the gradient
            call FlushCPvec(G)
            call CPMatVecProd(A,R,G,.TRUE.)
            call VecSignChange(G,1,SIZE(G%coef))
         ENDIF

      ENDDO

      end subroutine SolveBPsimpleCP

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine SolveBPsimple(B,A,X,R,G,csp)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Computes the vector solving the LS_tau problem:
! Minimize ||Ax - b||_2 with respect to x, subject to ||x||_1 <= tau
! This version uses the discrete cosine transform for the matrix
! multiplication step. See Algorithm 1 in: 
! van der Berg and Friedlander, SIAM J. Sci. Comput. 31 (2008) 890-912

      implicit none
      TYPE (CSpar), INTENT(IN)    :: csp
      TYPE (Configs), INTENT(IN)  :: B    ! Data to fit
      TYPE (Configs), INTENT(OUT) :: R    ! Residual of fit
      TYPE (CPvec), INTENT(IN)    :: A    ! Transformation matrix
      TYPE (CPvec), INTENT(OUT)   :: X,G  ! Solution, Gradient
      TYPE (Configs) :: Rnew,Ct,Ctt,Ott
      TYPE (CPvec)   :: Ax,Xnew,Gnew,Xt
      real*8, parameter    :: redtol=1.d-12
      real*8  :: tau,rnorm
      real*8  :: sigma,bptol,lstol,opttol,dectol,f,fnew,ftmp
      real*8  :: aax,bx,cx,step,l2,l1
      integer :: iter,maxit,maxLineErrors,nals
      integer :: rkx,i,j,gst
      character(len=72) :: messg
      logical :: project=.TRUE.

      write(*,'(/A/)') '*** BP_simple ***'

!     Set parameters from input file
      rkx=csp%pesrank
      nals=csp%nals
      maxit=csp%ncycle
      maxLineErrors=csp%maxlnerr
      sigma=csp%sigma
      bptol=csp%bptol
      lstol=csp%lstol
      opttol=csp%opttol
      dectol=csp%dectol

      call SetReductionParameters(rkx,nals,redtol,.FALSE.,csp%red2D,&
                                  csp%redND)

!     Initial values
      tau=0.d0
      iter=0

!!! TEST
      call GetZeroCPvec(Xt,B%nbas)
      write(*,*) 'Xt has ',SIZE(Xt%nbas),' dofs'
      gst=0
      DO j=1,SIZE(Xt%nbas)
         DO i=1,Xt%nbas(j)
            Xt%base(gst+i,1)=REAL(Xt%nbas(j)-i)
         ENDDO
         gst=gst+Xt%nbas(j)
      ENDDO
      call NORMBASE(Xt)
      Xt%coef(1)=1.d0
      write(*,'(/A/)') 'Here is Xt:'
      call PrintCPvec(Xt)
      call ExtractTopConfigs(Xt,Ctt,rkx)
      write(*,'(/A/)') 'Top configs of Xt:'
      call PrintConfigs(Ctt)
      call FlushCPvec(Xt)
!!!

!     Initialize zero solution vector for BP-sigma
      call GetZeroCPvec(X,B%nbas)

!     Initialize residual config. list and objective function value
      call CopyConfigsWtoV(R,B)
      rnorm=twonorm(R)
      fnew=0.5*rnorm**2
      f=fnew

!     Calculate the gradient: G = -A^T*R
      call GetCPGradient(R,A,G)

      IF (project) THEN
         call ConfigSetOverlap(Ctt,Ott,G)
         call FlushCPvec(G)
         call TrimZeroConfigs(Ott,1.d-12)
!         write(*,*) 'Projection of initial G onto guess configs:'
!         call PrintConfigs(Ott)
         call Config2CP(G,Ott)
         call FlushConfigs(Ott)
      ELSE
!         call reduc(G)
         call ExtractTopConfigs(G,Ct,rkx)
         call FlushCPvec(G)
         call TrimZeroConfigs(Ct,sigma)
         write(*,*) 'G (configs), initial'
         call PrintConfigs(Ct)
         call Config2CP(G,Ct)
         call FlushConfigs(Ct)
      ENDIF



!     Early exit if the norm of the residual is less than sigma
!     (in which case the initial zero vector is already feasible)
      IF (rnorm.lt.sigma) RETURN

      DO
         iter=iter+1

!        Exit conditions
         IF (sqrt(2*fnew).lt.sigma) THEN
            write(*,'(A)') 'Successful exit due to small residual'
            EXIT
         ELSEIF (SIZE(G%coef).eq.1 .and. G%coef(1).eq.0.d0) THEN
!!! Stuff to add:
!   Test: was convergence not reached due to the rank being too small
!   or due to important configurations being left out of the guess
!   (even though there is "room" within the specified rank). In the
!   latter case, I would like to discard small configs in the guess
!   and replace them with different guess configs
            write(*,'(A)') 'Exit due to zero projected gradient'
            EXIT
         ELSEIF (iter.ge.maxit) THEN
            write(*,'(A)') 'Exit due to too many iterations'
            EXIT
         ENDIF

!        First save objective function value before updating
         f=fnew

!        NR line search
         call PESCPbracket(B,Rnew,X,G,A,Xnew,rkx,tau,sigma,f,aax,bx,cx)
         call PESCPminimize(B,Rnew,X,G,A,Xnew,rkx,tau,sigma,&
                               aax,bx,cx,step,ftmp)

         IF (project) THEN
            call ConfigSetOverlap(Ctt,Ott,Xnew)
            call FlushCPvec(Xnew)
            call TrimZeroConfigs(Ott,sigma)
            l1=onenorm(Ott)
!            write(*,*) 'Projection of Xnew onto guess configs:'
!            call PrintConfigs(Ott)
            call Config2CP(Xnew,Ott)
            call FlushConfigs(Ott)
         ELSE
!           Reduce the rank of Xnew
!            call reduc(Xnew)
!            l1=0.d0
            call ExtractTopConfigs(Xnew,Ct,rkx)
            call FlushCPvec(Xnew)
            call TrimZeroConfigs(Ct,sigma)
            l1=onenorm(Ct)
!            write(*,*) 'Xnew (configs), iter = ',iter
!            call PrintConfigs(Ct)
            call Config2CP(Xnew,Ct)
            call FlushConfigs(Ct)
         ENDIF

!        Calculate the residual and objective function value
!        for the Xnew obtained after reduction
         call CPMatVecProd(A,Xnew,Ax,.FALSE.)
         call GetResidual(B,Ax,Rnew,l2)
         call FlushCPvec(Ax)

         IF (1.eq.1) THEN !0.5*l2**2.lt.f) THEN
            fnew=0.5*l2**2

            write(*,*) iter,sqrt(2*ftmp),l2,l1,SIZE(Xnew%coef)

!           Update the gradient
            call GetCPGradient(Rnew,A,Gnew)

            IF (project) THEN
               call ConfigSetOverlap(Ctt,Ott,Gnew)
               call FlushCPvec(Gnew)
!               call TrimZeroConfigs(Ott,1.d-12)
!               write(*,*) 'Projection of Gnew onto guess configs:'
!               call PrintConfigs(Ott)
               call Config2CP(Gnew,Ott)
               call FlushConfigs(Ott)
            ELSE
!               call reduc(Gnew)
               call ExtractTopConfigs(Gnew,Ct,rkx)
               call FlushCPvec(Gnew)
               call TrimZeroConfigs(Ct,sigma)
!               write(*,*) 'Gnew (configs), iter = ',iter
!               call PrintConfigs(Ct)
               call Config2CP(Gnew,Ct)
               call FlushConfigs(Ct)
            ENDIF

!           Replace X <-- Xnew, R <-- Rnew, G <-- Gnew
            call ReplaceVwithW(X,Xnew)
            call ReplaceVwithW(G,Gnew)
            call ReplaceConfigsVwithW(R,Rnew)

!        Do not update if residual gets worse
         ELSE
            write(*,*) iter
            call FlushCPvec(Xnew)
            call FlushConfigs(Rnew)

!           Recompute the gradient
            call FlushCPvec(G)
            call GetCPGradient(R,A,G)
!            call reduc(G)
            call ExtractTopConfigs(G,Ct,rkx)
            call FlushCPvec(G)
            call TrimZeroConfigs(Ct,sigma)
            call Config2CP(G,Ct)
            call FlushConfigs(Ct)
         ENDIF
      ENDDO

      call FlushConfigs(Ctt)
      call ordre(X)

      end subroutine SolveBPsimple

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine GetXonGlineA(X,Xnew,G,R,A,B,step,tau,sigma,f,rkx)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Computes the new value of CP-vector X, the residual, and the objective
! function value along the gradient line

      implicit none
      TYPE (CPvec), INTENT(IN)  :: B,X,G,A
      TYPE (CPvec), INTENT(OUT) :: Xnew,R
      TYPE (Configs) :: Ct
      integer, intent(in) :: rkx
      real*8, intent(in)  :: step,tau,sigma
      real*8, intent(out) :: f
      real*8 :: l22,bnorm2

      bnorm2=tau ! bnorm2 is temporarily passed via tau

!     Get rid of the old Xnew and residual, if they are allocated
      call FlushCPvec(Xnew)
      call FlushCPvec(R)

!     Calculate Xnew and project onto set with ||x||_1 <= tau
      call CopyWtoV(Xnew,X)
      call SUMVECVEC(Xnew,1.d0,G,step)

!     Calculate the residual and objective function value
      call CPMatVecProd(A,Xnew,R,.FALSE.)
      l22=bnorm2-2*PRODVV(B,R)+PRODVV(R)
      f=0.5*l22
      call SUMVECVEC(R,-1.d0,B,1.d0)

!      call reduc(R)
!      call ExtractTopConfigs(R,Ct,rkx)
!      call FlushCPvec(R)
!      call TrimZeroConfigs(Ct,sigma)
!      call Config2CP(R,Ct)
!      call FlushConfigs(Ct)

      end subroutine GetXonGlineA

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine BlockRichard(v,H,npow,bounds)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Applies Richardson solver to find H*x = v

      implicit none
      TYPE (CPvec), INTENT(INOUT) :: v
      TYPE (CPvec), INTENT(IN) :: H(:,:)
      TYPE (CPvec) :: w,x,y
      integer, intent(in) :: npow
      real*8, intent(in)  :: bounds(2)
      real*8  :: Escale,Eshift
      integer :: i

      Escale=2.d0/(bounds(2)+bounds(1))
      Eshift=0

!     Copy v to x. x is the vector to be improved
      call CopyWtoV(x,v)

      do i=1,npow
!        x_i+1 = x_i + Escale*[v - (H - Eshift*1)*x_i]
         call PRODHV(x,w,H,0,Eshift)  !!! note 0 turns off Eshift
         call SUMVECVEC(w,1.d0,v,-1.d0)
         call SUMVECVEC(w,-Escale,x,1.d0)

!        Reduce and normalize x
         call reduc(x,w)
         call NORMCOEF(x)
         call FlushCPvec(w)
      enddo

!     The improved x overwrites v
      call ReplaceVwithW(v,x)

      end subroutine BlockRichard

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      
      subroutine PISTRecursed(v,H,npow,Etarget,bounds)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Applies Richardson solver to find H*x = v

      implicit none
      TYPE (CPvec), INTENT(INOUT) :: v
      TYPE (CPvec), INTENT(IN) :: H(:,:)
      TYPE (CPvec) :: w,x,y 
      integer, intent(in) :: npow
      real*8, intent(in)  :: Etarget,bounds(2)
      real*8  :: Escale
      integer :: i

!     Choose the scale factor
      Escale=1.d0/max(abs(Etarget-bounds(1)),abs(bounds(2)-Etarget))**2

!      write(*,*)
!      write(*,*) 'Target E = ',Etarget
!      write(*,*)

!      call GetRandomCPvec(x,v%nbas,1)
!      call NORMCOEF(x)
!      call ReplaceVwithW(v,x)

!      write(*,*) 'Rayleigh quot of v:',0,RayleighQuotient(v,H)

      do i=1,npow
!        x_i+1 = x_i + Escale*[v - (H - Etarget*1)*x_i]
         call CopyWtoV(x,v)
         call PRODHV(v,w,H,1,Etarget)
         call reduc(x,w)
         call FlushCPvec(w)
         call PRODHV(x,w,H,1,Etarget)
         call FlushCPvec(x)
         call CopyWtoV(x,v) 
         call SUMVECVEC(x,1.d0,w,-Escale)
         call FlushCPvec(w)

!        Reduce and normalize v
         call reduc(v,x)
         call NORMCOEF(v)
         call FlushCPvec(x)

!         write(*,*) 'Rayleigh quot of v:',i,RayleighQuotient(v,H)
      enddo

!      call AbortWithError("DONE")

      end subroutine PISTRecursed

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine BlockIterateArn(Q,H,avec,npow,ortho,bounds,oldE,lokE)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!     Performs the power iteration cycle on a block of vectors

      implicit none
      TYPE (CPvec), INTENT(INOUT) :: Q(:)
      TYPE (CPvec), INTENT(IN) :: H(:,:)
      real*8, allocatable, intent(inout) :: avec(:)
      real*8,  allocatable   :: QHQ(:,:),S(:,:)
      real*8,  intent(inout) :: oldE(:)
      logical, intent(inout) :: lokE(:)
      integer, intent(in) :: npow
      logical, intent(in) :: ortho
      real*8, intent(in)  :: bounds(2)
      integer :: nbloc,j,k
      real*8  :: t1,t2,Eshift,lastpvv
      real*8, parameter :: tol=1.d-15

      call CPU_TIME(t1)

!     Set parameters
      nbloc=SIZE(Q)

      write(*,'(/X,A/)') 'BlockIterateArn() called...'

      call GetBlockShift(avec,bounds,Eshift)

      DO k=1,nbloc
!        Skip already converged eigenvalues
         IF (lokE(k)) CYCLE
         write(*,'(4X,A,I3)') 'Operating on vector nr:',k
         call BlockRecurseArn(k,Q,H,npow,Eshift,lastpvv)
!        Test the eigenvalue for convergence
         IF (abs((oldE(k)-lastpvv)/lastpvv).lt.tol .and. &
             ALL(lokE(1:k-1))) THEN
             lokE(k)=.TRUE.
             write(*,*) 'Eigenvalue lock : ',k,lastpvv
         ENDIF
         oldE(k)=lastpvv
      ENDDO
      call SortVecs(Q,oldE)

!     Compute eigenvalues and update vectors
      write(*,'(4X,A)')'Computing eigenvalues...'

      allocate(QHQ(nbloc,nbloc),S(nbloc,nbloc))
!     Calculate QHQ and S matrices
      call GetQHQ(Q,H,QHQ)
      call GetOverlaps(Q,S)
!     Diagonalize QHQ, accounting for overlaps
      call SolveGenEigval(avec,S,QHQ,'V')
      deallocate(QHQ,S)

      call CPU_TIME(t2)

!      write(*,'(/X,A,f9.2/)') 'BlockIterateArn() time (s) :',t2-t1

      end subroutine BlockIterateArn

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine BlockRecurseArn(k,Q,H,npow,Eshift,lastpvv)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Applies Hamiltonian (H-E)^npow*v to vector v
! The ishift parameter controls the shifting

      implicit none
      TYPE (CPvec), INTENT(INOUT) :: Q(:)
      TYPE (CPvec), INTENT(IN) :: H(:,:)
      TYPE (CPvec) :: u,w
      integer, intent(in) :: npow,k
      real*8, intent(in)  :: Eshift
      real*8, intent(out) :: lastpvv
      real*8, allocatable :: vivj(:)
      integer :: i,j,nbloc
      real*8  :: qhq,qhqold

      nbloc=SIZE(Q)
      ALLOCATE(vivj(nbloc))

      qhqold=1.d5
      do i=1,npow
!         write(*,'(6X,A,I3)') 'Power iteration no: ',i
!        w <-- H*v; then v <-- w
         call PRODHV(Q(k),w,H,1,Eshift)

!        Project out Q(j) for all j < k
         IF (k.gt.1) THEN
!$omp parallel
!$omp do private(j) schedule(static)
            DO j=1,k-1
               vivj(j)=-PRODVV(w,Q(j))
            ENDDO
!$omp end do
!$omp end parallel
            call SUMLCVEC(u,Q(1:k-1),vivj(1:k-1))
            call SUMVECVEC(w,1.d0,u,1.d0)
            call FlushCPvec(u)
         ENDIF

         IF (i.eq.npow) lastpvv=PRODVV(Q(k),w)+Eshift
         qhq=PRODVV(Q(k),w)+Eshift
         write(*,'(6X,A,I3,A,2(X,f22.12))') 'Power itn: ',i,&
         ', QHQ =',qhq,qhq-qhqold
         qhqold=qhq

!        Reduce and normalize v
         call reduc(Q(k),w)
         call NORMCOEF(Q(k))
         call FlushCPvec(w)
      enddo

      DEALLOCATE(vivj)

      end subroutine BlockRecurseArn

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

!     A scrap of code to print a vector randomly

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      real*8 :: x(1)

         IF (SIZE(v%nbas).ge.4) THEN
            call random_number(x)
            IF (x(1).lt. 0.01) THEN
               write(*,*) 'Vector before ALS'
               write(*,*) 'ndof = ',SIZE(w%nbas),'; rank = ',SIZE(w%coef)
               call NORMBASE(w)
               call ordre(w)
               call PrintCPvec(w)
               write(*,*) 'Vector after ALS'
               write(*,*) 'ndof = ',SIZE(v%nbas),'; rank = ',SIZE(v%coef)
               call NORMBASE(v)
               call ordre(v)
               call PrintCPvec(v)
               call AbortWithError('done')
            ENDIF
         ENDIF

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine pGRAMORTHO(Q,k)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Orthogonalizes a block of CP-format vectors via Gram-Schmidt, assuming
! the first k vectors are already orthonormal

      implicit none
      TYPE (CPvec), INTENT(INOUT) :: Q(:)
      TYPE (CPvec)  :: v
      integer, intent(in) :: k
      real*8, allocatable :: vivj(:)
      integer :: i,j,nbloc

      call AbortWithError('Hamiltonian not recognized')

      nbloc=size(Q)


      IF (k.lt.0 .or. k.ge.nbloc) &
         call AbortWithError('pGRAMORTHO(): k is out of range')

      ALLOCATE(vivj(nbloc))

!     Loop through the remaining vectors
!     for each, project out all preceding vectors
      do i=k+1,nbloc

!        Normalize i-th vector
         call NORMCOEF(Q(i))

!        Get weights
         vivj(i)=1.d0

!$omp parallel
!$omp do private(j) schedule(static)
         do j=1,i-1
!           Q(i) <- Q(i) - <Q(i),Q(j)>*Q(j)
            vivj(j)=-PRODVV(Q(i),Q(j))
         enddo
!$omp end do
!$omp end parallel

!        Compute the orthogonalized vector
         call SUMLCVEC(v,Q(1:i),vivj(1:i))

!        Reduce v into Q(i), normalize
         call reduc(Q(i),v)
         call NORMCOEF(Q(i))
      enddo

      DEALLOCATE(vivj)

      end subroutine pGRAMORTHO

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine pUpdateVecs(Q,QHQ,k)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Replaces a block of vectors Q with the eigenvectors whose coefficients
! are contained in QHQ. The first k vectors are "frozen"

      implicit none
      TYPE (CPvec), INTENT(INOUT) :: Q(:)
      TYPE (CPvec), ALLOCATABLE   :: Qold(:)
      real*8, intent(in)  :: QHQ(:,:)
      integer, intent(in) :: k
      integer :: i,nbloc

      nbloc=SIZE(Q)

      IF (k.lt.0 .or. k.ge.nbloc) &
         call AbortWithError('pGRAMORTHO(): k is out of range')

!     Copy Q to Qold
      ALLOCATE(Qold(nbloc))

!$omp parallel
!$omp do private(i)
!     The first k vectors are copied since they are not replaced later
      DO i=1,k
         call CopyWtoV(Qold(i),Q(i))
      ENDDO
!$omp enddo
!$omp do private(i)
      DO i=k+1,nbloc
         call ReplaceVwithW(Qold(i),Q(i))
      ENDDO
!$omp enddo
!$omp end parallel

!$omp parallel
!$omp do private(i)
      DO i=k+1,nbloc
         call GetEigenFxn(Q(i),Qold,QHQ,i)
!        reduce and normalize Q(i)
         call reduc(Q(i))
         call NORMCOEF(Q(i))
      ENDDO
!$omp enddo
!$omp end parallel

      DEALLOCATE(Qold)

      end subroutine pUpdateVecs

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine SolveWithSVD(svals,A,U,VT,nrkf)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! SVD of m x n matrix, using call to LAPACK DGESVD

      implicit none
      real*8, allocatable, intent(inout) :: A(:,:)
      real*8, allocatable, intent(out)   :: U(:,:),VT(:,:)
      real*8, allocatable, intent(out)   :: svals(:)
      real*8, allocatable :: WORK(:),V(:,:)
      integer, intent(in) :: nrkf
      integer :: IW(8*SIZE(svals))
      integer :: i,j,n,m,mmn,nrk,INFO,LWORK
      real*8  :: optdim(1)
      logical :: useSDD,useID

      useID=.FALSE.
      useSDD=.FALSE.

      m=SIZE(A,1)
      n=SIZE(A,2)
      mmn=min(m,n)

!     Approximate SVD using Interpolative Decomposition
!     (not as accurate as SVD, but faster)
      IF (useID) THEN

         IF (nrkf.le.1) THEN
            nrk=mmn
         ELSE
            nrk=min(mmn,nrkf,2)
         ENDIF

         LWORK=((2*nrk+28)*m+(6*nrk+21)*n+25*nrk**2+100)
         ALLOCATE(WORK(LWORK),U(m,nrk),V(n,nrk),svals(nrk))
         CALL iddr_aidi(m,n,nrk,WORK)
         CALL iddr_asvd(m,n,A,nrk,WORK,U,V,svals,INFO)
         DEALLOCATE(WORK)

!        Error checking
         if (INFO.ne.0) then
            write(*,*) 'error in the iddr_asvd, info=',INFO
            call AbortWithError('error in DGESDD')
         endif

!        Copy V -> VT since this routine gives V
         ALLOCATE(VT(nrk,n))
         DO i=1,n
            DO j=1,nrk
               VT(j,i)=V(i,j)
            ENDDO
         ENDDO
         DEALLOCATE(V)

      ELSE
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine SolveWithSVD(svals,A,U,VT,nrkf)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! SVD of m x n matrix, using call to LAPACK DGESVD

      implicit none
      real*8, allocatable, intent(inout) :: A(:,:)
      real*8, allocatable, intent(out)   :: U(:,:),VT(:,:)
      real*8, allocatable, intent(out)   :: svals(:)
      real*8, allocatable :: WORK(:),V(:,:)
      integer, intent(in) :: nrkf
      integer :: IW(8*SIZE(svals))
      integer :: i,j,n,m,mmn,nrk,INFO,LWORK
      real*8  :: optdim(1)
      logical :: useSDD,useID

      useID=.FALSE.
      useSDD=.FALSE.

      m=SIZE(A,1)
      n=SIZE(A,2)
      mmn=min(m,n)

!     Approximate SVD using Interpolative Decomposition
!     (not as accurate as SVD, but faster)
      IF (useID) THEN

         IF (nrkf.le.1) THEN
            nrk=mmn
         ELSE
            nrk=min(mmn,nrkf,2)
         ENDIF

         LWORK=((2*nrk+28)*m+(6*nrk+21)*n+25*nrk**2+100)
         ALLOCATE(WORK(LWORK),U(m,nrk),V(n,nrk),svals(nrk))
         CALL iddr_aidi(m,n,nrk,WORK)
         CALL iddr_asvd(m,n,A,nrk,WORK,U,V,svals,INFO)
         DEALLOCATE(WORK)

!        Error checking
         if (INFO.ne.0) then
            write(*,*) 'error in the iddr_asvd, info=',INFO
            call AbortWithError('error in DGESDD')
         endif

!        Copy V -> VT since this routine gives V
         ALLOCATE(VT(nrk,n))
         DO i=1,n
            DO j=1,nrk
               VT(j,i)=V(i,j)
            ENDDO
         ENDDO
         DEALLOCATE(V)

      ELSE
         ALLOCATE(U(m,mmn),VT(mmn,n),svals(mmn))

         IF (useSDD) THEN

!           Calculate optimal LWORK value for DGESDD
            CALL DGESDD('S',m,n,A,m,svals,U,m,VT,mmn,optdim,-1,IW,INFO)
            LWORK=INT(optdim(1))
            ALLOCATE(WORK(LWORK))

!           Now calculate SVD...
            CALL DGESDD('S',m,n,A,m,svals,U,m,VT,mmn,WORK,LWORK,IW,INFO)
            DEALLOCATE(WORK)

!           Error checking
            if (INFO.ne.0) then
               write(*,*) 'error in the DGESDD, info=',INFO
               call AbortWithError('error in DGESDD')
            endif

         ELSE

!           Calculate optimal LWORK value for DGESVD
            CALL DGESVD('S','S',m,n,A,m,svals,U,m,VT,mmn,optdim,-1,INFO)
            LWORK=INT(optdim(1))
            ALLOCATE(WORK(LWORK))

!           Now calculate SVD...
            CALL DGESVD('S','S',m,n,A,m,svals,U,m,VT,mmn,WORK,LWORK,INFO)
            DEALLOCATE(WORK)

!           Error checking
            if (INFO.ne.0) then
               write(*,*) 'error in the DGESVD, info=',INFO
               call AbortWithError('error in DGESVD')
            endif

         ENDIF
      ENDIF

      end subroutine SolveWithSVD

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine PES2CP(H)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Builds CP-format representation of a PES stored in type 'Hamiltonian'

      implicit none
      TYPE (Hamiltonian), INTENT(IN) :: H
      TYPE (CPvec) :: V,w
      integer, allocatable :: nbastmp(:)
      integer :: ndof,nop,nrk,ndf,i,j,k,thedof,theop
      real*8, parameter :: redtol=1.d-12

!     Parameters
      ndof=SIZE(H%dofs,2)
      nop=H%nterms(1)
      nrk=nop-ndof
      ALLOCATE(nbastmp(ndof))

!     Determine the number of basis functions for each DOF in the PES
      nbastmp=0
      DO k=1,nop
         ndf=H%ndof(k,1)
         DO j=1,ndf
            thedof=H%dofs(k,j,1)
            theop=H%ops(k,j,1)
            IF (theop.gt.nbastmp(thedof)) nbastmp(thedof)=theop
         ENDDO
      ENDDO
      nbastmp=nbastmp+1

!     Construct the CP vector
      CALL NewCPvec(V,nbastmp,nrk)
      V%base=1.d-16

!     Recycle the nbastmp array to hold the index for where in the base
!     each DOF starts. Then initialize the base to 1.0 in the first
!     position for each DOF, which corresponds to the identity operation
      nbastmp(1)=1
      V%base(1,:)=1.d0
      DO j=2,ndof
         nbastmp(j)=nbastmp(j-1)+V%nbas(j)
         V%base(nbastmp(j),:)=1.d0
      ENDDO

!     Now loop over the potential terms and modify the CP-vector for
!     each accordingly
      i=1
      DO k=1,nop
         ndf=H%ndof(k,1)
!        Skip kinetic energy terms
         IF (.not.(H%ndof(k,1).eq.1 .and. H%ops(k,1,1).lt.0)) THEN
            ndf=H%ndof(k,1)
            DO j=1,ndf
               thedof=H%dofs(k,j,1)
               theop=H%ops(k,j,1)
!              Replace the 1.0 coef for the identity with a 1.0 coef
!              for the power of q
               V%base(nbastmp(thedof)+theop,i)=1.d0
               V%base(nbastmp(thedof),i)=1.d-16
            ENDDO
            V%coef(i)=abs(H%facs(k,1))
!           Change sign of base to keep coef positive
            IF (H%facs(k,1).lt.0.d0) THEN
               V%base(1:V%nbas(1),i)=-V%base(1:V%nbas(1),i)
            ENDIF
            i=i+1
         ENDIF
      ENDDO

      write(*,*) 'Original PES vector (in small chunks)'
      i=1
      k=5
      DO
         write(*,*) 'PES vec, rank',i,' through ',k
         CALL NewCPvec(w,V%nbas,k-i+1)
         w%coef(:)=v%coef(i:k)
         w%base(:,:)=v%base(:,i:k)
         CALL PrintCPvec(w)
         CALL FlushCPvec(w)
         i=i+5
         k=k+5
         IF (k.gt.SIZE(V%coef)) k=SIZE(V%coef)
         IF (i.gt.SIZE(V%coef)) EXIT
      ENDDO
      write(*,*)

      CALL reduc_bysorting(V)

      write(*,'(2(A,I0))')'Sorting reduced rank: ',nrk,' --> ',SIZE(V%coef)
      write(*,*)
      write(*,*) 'Reduced PES vector (in small chunks)'
      i=1
      k=5
      DO
         write(*,*) 'PES vec, rank',i,' through ',k
         CALL NewCPvec(w,V%nbas,k-i+1)
         w%coef(:)=v%coef(i:k)
         w%base(:,:)=v%base(:,i:k)
         CALL PrintCPvec(w)
         CALL FlushCPvec(w)
         i=i+5
         k=k+5
         IF (k.gt.SIZE(V%coef)) k=SIZE(V%coef)
         IF (i.gt.SIZE(V%coef)) EXIT
      ENDDO

      CALL FlushCPvec(V)
      DEALLOCATE(nbastmp)

      CALL AbortWithError('Done')

      end subroutine PES2CP

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine pDiagonalize(Q,H,avec,nconv)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! One-step function to solve the generalized eigenvalue problem and 
! update vectors

      implicit none
      TYPE (CPvec), INTENT(INOUT) :: Q(:)
      TYPE (CPvec), INTENT(IN) :: H(:,:)
      integer, intent(in)   :: nconv
      real*8, intent(inout) :: avec(:)
      real*8, allocatable   :: QHQ(:,:),S(:,:)
      integer :: nbloc,i

!     Set parameters
      nbloc=SIZE(Q)

      allocate(QHQ(nbloc,nbloc),S(nbloc,nbloc))

!     Calculate QHQ and S matrices
      call GetQHQ(Q,H,QHQ)
      call GetOverlaps(Q,S)

!!!   Needs partial version
!     Diagonalize QHQ, accounting for overlaps
      call SolveGenEigval(avec,S,QHQ,'V')

!!!   Needs partial version
!     Update block vectors after diagonalization
!     q^n_{new} <- sum_{i=1} ^ m U_{im} q^i_{old}
      call pUpdateVecs(Q,QHQ,nconv)

      deallocate(QHQ,S)

      end subroutine pDiagonalize

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine pUpdateVecs(Q,QHQ,nconv)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Replaces a block of vectors Q with the eigenvectors whose coefficients
! are contained in QHQ

      implicit none
      TYPE (CPvec), INTENT(INOUT) :: Q(:)
      TYPE (CPvec), ALLOCATABLE   :: Qold(:)
      integer, intent(in) :: nconv
      real*8, intent(in)  :: QHQ(:,:)
      integer :: i,nbloc

      nbloc=SIZE(Q)

!     Copy Q to Qold
      ALLOCATE(Qold(nbloc))

!$omp parallel
!$omp do private(i)
      DO i=1,nbloc
         IF (i.le.nconv) THEN
            call CopyWtoV(Qold(i),Q(i))
         ELSE
            call ReplaceVwithW(Qold(i),Q(i))
         ENDIF
      ENDDO
!$omp enddo
!$omp end parallel

!$omp parallel
!$omp do private(i)
      DO i=nconv+1,nbloc
         call GetEigenFxn(Q(i),Qold,QHQ,i)
!        reduce and normalize Q(i)
         call reduc(Q(i))
         call NORMCOEF(Q(i))
      ENDDO
!$omp enddo
!$omp end parallel

      DEALLOCATE(Qold)

      end subroutine pUpdateVecs

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      function CalcDiagonalOverlaps(V)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Computes amplitudes of diagonal terms in the force constant tensor

      implicit none
      TYPE (CPvec), ALLOCATABLE, INTENT(IN) :: V(:)
      TYPE (CPvec) :: vtmp
      integer :: i,j,k,ntens,otens,ndof,gst
      real*8  :: CalcDiagonalOverlaps

!     Set parameters
      ntens=SIZE(V)
      ndof=V(1)%nbas(1)

      CalcDiagonalOverlaps=0.d0
      DO i=1,ntens
         otens=SIZE(V(i)%nbas)
         DO j=1,ndof
!           Generate a unit vector for the diagonal term of choice
            call GetZeroCPvec(vtmp,V(i)%nbas)
            gst=0
            DO k=1,otens
               IF (k.gt.1) gst=gst+V(i)%nbas(k-1)
               vtmp%base(gst+j,1)=1.d0
               vtmp%coef(1)=1.d0
            ENDDO
            CalcDiagonalOverlaps=CalcDiagonalOverlaps+&
            abs(PRODVV(V(i),vtmp)**otens)
            call FlushCPvec(vtmp)
         ENDDO
      ENDDO

      end function CalcDiagonalOverlaps

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine ORTHONORMBASE(F)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Orthonormalizes Fbase, which modifies Fcoef

      implicit none
      TYPE (CPvec), INTENT(INOUT) :: F
      integer :: id,ndim,irk,jrk,nrkF,gstart,k
      real*8  :: vivj,norm1D

      nrkF=SIZE(F%coef)
      ndim=SIZE(F%nbas)

      gstart=0
      DO id=1,ndim
         IF (id.gt.1) gstart=gstart+F%nbas(id-1)

!        Normalize the first vector
         norm1D=0.d0
         DO k=1,F%nbas(id)
            norm1D=norm1D+F%base(gstart+k,1)**2
         ENDDO
         norm1D=sqrt(abs(norm1D))
         F%coef(1)=F%coef(1)*norm1D
         DO k=1,F%nbas(id)
            F%base(gstart+k,1)=F%base(gstart+k,1)/norm1D
         ENDDO

         DO irk=2,nrkF

!            norm1D=0.d0
!            DO k=1,F%nbas(id)
!               norm1D=norm1D+F%base(gstart+k,irk)**2
!            ENDDO
!            norm1D=sqrt(abs(norm1D))
!            F%coef(irk)=F%coef(irk)*norm1D
!            DO k=1,F%nbas(id)
!               F%base(gstart+k,irk)=F%base(gstart+k,irk)/norm1D
!            ENDDO

            DO jrk=1,irk-1
!              Calculate v1 <- v1 - <v1,v2>v2
               vivj=0.d0
               DO k=1,F%nbas(id)
                  vivj=vivj+F%base(gstart+k,irk)*F%base(gstart+k,jrk)
               ENDDO
               DO k=1,F%nbas(id)
                  F%base(gstart+k,irk)=&
                  F%base(gstart+k,irk)-vivj*F%base(gstart+k,jrk)
               ENDDO
            ENDDO

!           Normalize the orthogonalized vector
            norm1D=0.d0
            DO k=1,F%nbas(id)
               norm1D=norm1D+F%base(gstart+k,irk)**2
            ENDDO
            norm1D=sqrt(abs(norm1D))
            F%coef(irk)=F%coef(irk)*norm1D
            DO k=1,F%nbas(id)
               F%base(gstart+k,irk)=F%base(gstart+k,irk)/norm1D
            ENDDO
         ENDDO
      ENDDO

      end subroutine ORTHONORMBASE

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      function PRODND(F,G,nbas)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Calculates N-D dot product between two rank-1 parts of two vectors in
! separated representation. Only the bases are multiplied; coefficient
! multiplication is done elsewhere

      implicit none
      real*8, intent(in)  :: F(:),G(:)
      integer, intent(in) :: nbas(:)
      real*8  :: PRODND
      logical :: usebuiltin

      usebuiltin=.FALSE.

      IF (usebuiltin) THEN
         PRODND=PRODNDa(F,G,nbas)
      ELSE
         PRODND=PRODNDb(F,G,nbas)
!         PRODND=PRODNm1D(F,G,nbas,0)
      ENDIF

      end function PRODND

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      function PRODNDa(F,G,nbas)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Calculates N-D dot product between two rank-1 parts of two vectors in
! separated representation. Only the bases are multiplied; coefficient
! multiplication is done elsewhere

      implicit none
      real*8, intent(in)  :: F(:),G(:)
      integer, intent(in) :: nbas(:)
      real*8  :: PRODNDa
      integer :: id,ndim,gi,gf

      ndim=SIZE(nbas)

      prodNDa=1.d0
      gi=1
      do id=1,ndim
         gf=gi+nbas(id)-1
         prodNDa=prodNDa*dot_product(F(gi:gf),G(gi:gf))
         gi=gi+nbas(id)
      enddo

      end function PRODNDa

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      function PRODNDb(F,G,nbas)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Calculates N-D dot product between two rank-1 parts of two vectors in
! separated representation. Only the bases are multiplied; coefficient
! multiplication is done elsewhere

      implicit none
      real*8, intent(in)  :: F(:),G(:)
      integer, intent(in) :: nbas(:)
      real*8  :: PRODNDb,prod1D
      integer :: i,ndim,gi,j

      ndim=SIZE(nbas)

      prodNDb=1.d0
      gi=0
      do i=1,ndim
         prod1D=0.d0
         do j=1,nbas(i)
            prod1D=prod1D+F(gi+j)*G(gi+j)
         enddo
         prodNDb=prodNDb*prod1D
         gi=gi+nbas(i)
      enddo

      end function PRODNDb

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine EstSpectralRange(npow,Q,H,bounds)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Estimates the spectral range of the Hamiltonian using power method

      implicit none
      TYPE (CPvec), INTENT(IN) :: H(:,:)
      TYPE (CPvec) :: Q(:)
      TYPE (CPvec) :: v,w
      integer, intent(in) :: npow
      real*8, intent(out) :: bounds(2)
      integer :: i,gst
      real*8  :: tol,oldb

      tol=1.0

      write(*,'(X,A/)') 'Power spectral range estimation'
      write(*,*) '   Upper bound:'

!     Try to converge the highest eigenvalue using the power method
      call GetZeroCPvec(v,Q(1)%nbas)
      v%coef(1)=1.d0
      gst=0
      DO i=1,SIZE(v%nbas)
         gst=gst+v%nbas(i)
         v%base(gst,1)=1.d0
      ENDDO
      oldb=1.d99
      DO i=1,npow
         call PRODHV(v,w,H,1,0.d0)
         bounds(2)=PRODVV(v,w)
         write(*,'(1X,f14.3)') bounds(2)
         IF (abs(bounds(2)-oldb).lt.tol) EXIT
         oldb=bounds(2)
!        Reduce and normalize v
         call reduc(v,w)
         call NORMCOEF(v)
         call FlushCPvec(w)
      ENDDO
      call FlushCPvec(v)

!     Shift by the higest eigenvalue to converge the lowest
      write(*,*) '   Lower bound:'
      call GetZeroCPvec(v,Q(1)%nbas)
      v%coef(1)=1.d0
      gst=1
      DO i=1,SIZE(v%nbas)
         v%base(gst,1)=1.d0
         gst=gst+v%nbas(i)
      ENDDO
      oldb=1.d99
      DO i=1,npow
         call PRODHV(v,w,H,1,bounds(2))
         bounds(1)=PRODVV(v,w)+bounds(2)
         write(*,'(1X,f14.3)') bounds(1)
         IF (abs(bounds(1)-oldb).lt.tol) EXIT
         oldb=bounds(1)
!        Reduce and normalize v
         call reduc(v,w)
         call NORMCOEF(v)
         call FlushCPvec(w)
      ENDDO
      call FlushCPvec(v)

      end subroutine EstSpectralRange

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine GetConfigList3(G,rF,v)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Beginning with CP-vector G, this extracts the dominant configurations
! in terms of the product configurations of unit vectors. rF is the max
! number of configurations to keep per term

      implicit none
      TYPE (CPvec), INTENT(IN)  :: G
      TYPE (Configs), intent(out) :: v
      TYPE (Configs) :: w
      integer, intent(in)  :: rF
      real*8, allocatable  :: bas1D(:,:),tabindx(:,:)
      real*8  :: cuttol,biggest,t1,t2
      integer :: rG,rrx,ndof,mxbas,i,j,k,l,n,imod,gst,rterm,rtot
      real*8, parameter  :: tol=1.d-15

      write(*,*) '*** GetConfigList3() ***'

      call CPU_TIME(t1)

!     Set parameters
      rG=SIZE(G%coef)
      ndof=SIZE(G%nbas)
      mxbas=MAXVAL(G%nbas)

!     Truncate rank if > direct-product size (unlikely if > 2 DOF)
      rrx=1
      DO j=1,ndof
         rrx=rrx*G%nbas(j)
         IF (rrx.ge.rF) EXIT
      ENDDO
      rrx=min(rrx,rF)

      call NewConfigs(v,G%nbas,rrx*rG)

      ALLOCATE(bas1D(ndof,mxbas),tabindx(ndof,mxbas))
      tabindx=0.d0

!     Loop over terms in G
      rtot=0
      DO i=1,rG

!        Get the list of 1D basis functions and sort by decreasing
!        coefficient magnitude
         bas1D=0.d0
         gst=0
         DO j=1,ndof
            n=G%nbas(j)
!           Copy coefficient into bas1D and set the table index
            DO k=1,n
               imod=gst+k
               bas1D(j,k)=abs(G%base(imod,i))
               tabindx(j,k)=SIGN(REAL(k),G%base(imod,i))
            ENDDO
            call dsort(bas1D(j,1:n),tabindx(j,1:n),G%nbas(j),-2)
            gst=gst+G%nbas(j)
         ENDDO

!        First iteration: set the biggest value
         IF (i.eq.1) THEN
            biggest=abs(G%coef(1))
            DO j=1,ndof
               biggest=biggest*bas1D(j,1)
            ENDDO
         ENDIF
         cuttol=tol*biggest/abs(G%coef(i))

!        Set the new cutoff tolerence and generate the config list
         call NewConfigs(w,G%nbas,rrx)

         IF (abs(G%coef(i)).le.tol*biggest/1.d300) cuttol=1.d300
         call sortDPbasis(w,bas1D,cuttol,rterm)

         biggest=max(biggest,abs(G%coef(i))*w%coef(1))

!        Replace the quantum numbers with those in tabindx
!        Scale the coefficients in w by the coefficient in G
         w%coef=G%coef(i)*w%coef
         DO k=1,rterm
            DO j=1,ndof
               IF (tabindx(j,w%qns(k,j)).lt.0.d0) w%coef(k)=-w%coef(k)
               w%qns(k,j)=abs(tabindx(j,w%qns(k,j)))
            ENDDO
         ENDDO

!        Update the total list of configurations
         IF (rterm.gt.0) THEN
            call GenCopyConfigsWtoV(v,w,rtot+1,rtot+rterm,1,rterm)
            rtot=rtot+rterm
         ENDIF

         call FlushConfigs(w)
      ENDDO

!      write(*,'(/A,I0/)') 'Original list, rank = '&
!                          ,SIZE(v%coef)
!      call PrintConfigs(v)

      call sumduplicateconfigs(v)

!      write(*,'(/A,I0/)') 'Summed duplicate list, rank = '&
!                          ,SIZE(v%coef)
!      call PrintConfigs(v)

!     Sort the configuration list and resize
      call SortConfigsByCoef(v)
      call TrimZeroConfigs(v,v%coef(1)*tol)

!      write(*,'(/A,I0/)') 'Final sorted, trimmed list, rank = '&
!                          ,SIZE(v%coef)
!      call PrintConfigs(v)

      DEALLOCATE(bas1D,tabindx)

      call CPU_TIME(t2)
      write(*,*)
      write(*,*) 'GetConfigList3 time: ',t2-t1

!      call AbortWithError('*** Done GetConfigList3() ***')

      end subroutine GetConfigList3

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine reduc_ALT(G,F,nitn,kortho)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Receives G (represented in reduced form) and F (trial vector to be
! reduced), and approximates G by F using alternating least squares.
! The subroutine optimizes F in dimensions k=1,ndim in succession.
! Setting kortho equal to one of the DOFs will result in an orthogonal
! set of fs for that DOF provided that the rank, rF, is equal to n, the
! basis size for that DOF

      implicit none
      TYPE (CPvec), INTENT(IN) :: G
      TYPE (CPvec), INTENT(INOUT) :: F
      TYPE (CPvec) :: T
      integer, intent(in) :: nitn
      logical, intent(in) :: kortho(:)
      real*8, dimension(:,:), allocatable :: PS,PSk,PSkm1,bjk,U,VT,BB
      real*8, allocatable :: svals(:)
      real*8  :: rnorm,gtmp
      integer :: rG,rF,ndim,i,j,ir,imod,k,l,n,gi,gf,itn,kp
      logical :: update

      TYPE (CPvec) :: v

      IF (nitn.eq.0) return

!      write(*,*) '*** reduc_ALT(): ***'

!     Set parameters
      rG=SIZE(G%coef)
      rF=SIZE(F%coef)
      ndim=SIZE(G%nbas)

!     Error checking
      IF (SIZE(kortho).ne.ndim) &
         call AbortWithError('reduc_ALT(): SIZE(kortho) != ndof')
      imod=0
      DO i=1,ndim
         IF (kortho(i)) THEN
            imod=imod+1
            IF (rF.gt.G%nbas(i)) THEN
               write(*,*) 'DOF: ',i,'; nbas(i)=',F%nbas(i),'; rF=',rF
               call AbortWithError("reduc_ALT(): rF > nbas(i)")
            ENDIF
         ENDIF
      ENDDO
      IF (imod.eq.0 .and. rF.gt.1) &
         call AbortWithError('reduc_ALT(): zero orthogonal DOFs!')

!     Update the ALS matrix PS if ndim > 3. For ndim <= 3 it
!     is faster to build PS at each iteration.
!     Building also avoids possible zero division during the update.
      update=.FALSE.
      IF (ndim.le.3)  update=.FALSE.

      allocate(PS(rG,rF),PSk(rG,rF),PSkm1(rG,rF))

84    continue

!     PS(l,l') = Pi_{i=2}^ndim < G_i^l , F_i^l' >
!     If PS is to be updated, initialize here with first DOF removed
      IF (update) THEN
          call CONSTPSk(F,G,2,PS)
          DO k=3,ndim
             call CONSTPSk(F,G,k,PSk)
             PS=PS*PSk
          ENDDO
      ENDIF

!     Main loop over ALS iterations
      kp=0
      DO itn=1,nitn

!        Loop over dimension k
         gi=1
         do k=1,ndim
            n=F%nbas(k)
            gf=gi+n-1

!           Update the BB and PS matrices of the linear system. This
!           also requires copying BBmem <-- BB since LAPACK destroys BB
            IF (update) THEN
               IF (kp.ne.0) then
                  call CONSTPSk(F,G,k,PSk)
                  call CONSTPSk(F,G,kp,PSkm1)
                  PS=PS*PSkm1/PSk
               ENDIF

!           Alternatively, build BB and PS from scratch
            ELSE
               kp=mod(k,ndim)+1
               call CONSTPSk(F,G,kp,PS)
               DO l=2,ndim-1
                  kp=mod(k+l-1,ndim)+1
                  call CONSTPSk(F,G,kp,PSk)
                  PS=PS*PSk
               ENDDO
            ENDIF

!           Calculate b_j_k ( l', nr) (Beylkin, eq. 3.4)
            allocate(bjk(n,rF))
            bjk=0.d0
            do ir=1,n
               imod=gi+ir-1
               do j=1,rG
                  gtmp=G%coef(j)*G%base(imod,j)
                  do i=1,rF
                     bjk(ir,i)=bjk(ir,i)+gtmp*PS(j,i)
                  enddo
               enddo
            enddo

!            write(*,*) 'PS b4 norm, itn,k=',itn,k
!            call PrintMatrix(PS)
!            write(*,*) 'PSk b4 norm, itn,k=',itn,k
!            call PrintMatrix(PSk)
!            write(*,*) 'bjk b4 norm, itn,k=',itn,k
!            call PrintMatrix(bjk)

!           Normalize the bjk vectors
            do i=1,rF
               rnorm=sqrt(abs(dot_product(bjk(:,i),bjk(:,i))))
               bjk(:,i)=bjk(:,i)/rnorm
            enddo

!            write(*,*) 'bjk after norm, itn,k=',itn,k
!            call PrintMatrix(bjk)

!           Polar decomposition orthogonalizes bjk for the kortho-th DOF
            IF (kortho(k)) THEN
               call SolveWithSVD(svals,bjk,U,VT)
               deallocate(bjk)
               call MatrixMult(U,.FALSE.,VT,.FALSE.,bjk)
               deallocate(U,VT,svals)
            ENDIF

!           New base of F
            F%base(gi:gf,1:rF)=bjk(1:n,1:rF)
            deallocate(bjk)

!           Check coefs of F for NaN values resulting from zero
!           division. If there are any, restart ALS without updating
            DO i=1,rF
               IF (F%base(gi,i).ne.F%base(gi,i)) THEN
                  write(*,*) 'reduc_ALT(): NaN on update; itn = ',itn
                  call FlushCPvec(F)
                  call GetRandomCPvec(F,G%nbas,rF)
                  update=.FALSE.
                  GOTO 84
               ENDIF
            ENDDO

!!!
!            ALLOCATE(svals(rF))
!            DO i=1,rF
!               call NewCPvec(T,F%nbas,1)
!               call GenCopyWtoV(T,F,1,1,i,i)
!               T%coef(1)=1.d0
!               svals(i)=PRODVV(G,T)
!               call FlushCPvec(T)
!            ENDDO
!            call CopyWtoV(T,F)
!            T%coef(:)=svals(:)
!            write(*,*) 'itn = ',itn,'; k = ',k,'; ||F-G||:',calc_FmG(G,T)
!            call FlushCPvec(T)
!            DEALLOCATE(svals)
!!!

            gi=gf+1
            kp=k
         enddo  ! loop over k
      ENDDO  ! loop over iterations

!     Compute the final coefficients of F. Most of the work required to
!     compute these is already in PS, so one only needs to multiply PS
!     by PSk for k = ndim and by the coefs of G to get <F,G>
      call CONSTPSk(F,G,ndim,PSk)
      PS=PS*PSk
      ALLOCATE(svals(rG))
      svals(:)=G%coef(:)
      call MatVecProd(PS,.TRUE.,svals)
      F%coef(:)=svals(:)

      deallocate(PS,PSk,PSkm1,svals)

!      write(*,*) 'Solution vec:'
!      call PrintCPvec(F)
!      write(*,*) '||F-G||:',calc_FmG(G,F)
!
!      ALLOCATE(BB(rF,rF))
!      DO k=1,ndim
!         call CONSTBBk(F,k,BB)
!         write(*,*) 'BB for DOF:',k
!         call PrintMatrix(BB)
!      ENDDO
!      DEALLOCATE(BB)

      end subroutine reduc_ALT

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine reduc_TSVD(G,F,nitn)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Receives G (represented in reduced form) and F (trial vector to be
! reduced), and approximates G by F using tensor-SVD
! see Chen and Saad, SIAM J. Mat. Anal. Appl. 30 (2009) 1709.
 
      implicit none
!      TYPE (CPvec), INTENT(IN) :: G
      TYPE (CPvec), INTENT(INOUT) :: G,F
      TYPE (CPvec) :: v
      integer, intent(in)   :: nitn
      real*8, dimension (:,:), allocatable :: PS,PSk,PSkm1,bjk,U,VT
      real*8, allocatable :: svals(:)
      real*8  :: valpen,rnorm,gtmp
      integer :: rG,rF,ndim,i,j,ir,imod,k,l,n,info,gst,itn,kp
      logical :: update

      IF (nitn.eq.0) return

!     Set parameters
      rG=SIZE(G%coef)
      rF=SIZE(F%coef)
      ndim=SIZE(G%nbas)

      write(*,'(/A/)') 'T-SVD reduction'
      write(*,*) 'rF = ',rF,'; rG = ',rG
      write(*,*) 'G'
      call ordre(G)
      call PrintCPvec(G)
      write(*,*) 'F'
      call ordre(F)
      call PrintCPvec(F)


      IF (rF.gt.MINVAL(F%nbas)) &
         call AbortWithError('No T-SVD possible for this rank')

!     Update the ALS matrices BB and PS if ndim > 3. For ndim <= 3 it
!     is faster to build BB and PS at each iteration.
!     Building also avoids possible zero division during the update.
      update=.TRUE.
      IF (ndim.le.4)  update=.FALSE.

      allocate(PS(rG,rF),PSk(rG,rF),PSkm1(rG,rF))

!     Penalty to avoid bad conditioning
      valpen=maxval(G%coef)*1.d-15

76    continue

!     PS(l,l') = Pi_{i=2}^ndim < G_i^l , F_i^l' >
!     If the matrix PS is to be updated, initialize
!     here with the first DOF removed
      IF (update) THEN
          call CONSTPSk(F,G,2,PS)
          DO k=3,ndim
             call CONSTPSk(F,G,k,PSk)
             PS=PS*PSk
          ENDDO
      ENDIF

!     Main loop over iterations
      kp=0
      DO itn=1,nitn

!        Loop over dimension k
         gst=0
         do k=1,ndim
            n=F%nbas(k)

!           PS matrix update
            IF (update) THEN
               IF (kp.ne.0) then
                  call CONSTPSk(F,G,k,PSk)
                  call CONSTPSk(F,G,kp,PSkm1)
                  PS=PS*PSkm1/PSk
               ENDIF

!           Alternatively, build PS from scratch
            ELSE 
               kp=mod(k,ndim)+1
               call CONSTPSk(F,G,kp,PS)
               DO l=2,ndim-1
                  kp=mod(k+l-1,ndim)+1
                  call CONSTPSk(F,G,kp,PSk)
                  PS=PS*PSk
               ENDDO
            ENDIF

!           Calculate b_j_k ( l', nr) (Beylkin, eq. 3.4)
            allocate(bjk(rF,n))
            bjk=0.d0
            do ir=1,n
               imod=gst+ir
               do j=1,rG
                  gtmp=G%coef(j)*G%base(imod,j)
                  do i=1,rF
                     bjk(i,ir)=bjk(i,ir)+gtmp*PS(j,i)*F%coef(i)
                  enddo
               enddo
            enddo

            write(*,*) 'F coefs, the alternate way'
            DO i=1,rF
               write(*,*) 'ko-ef = ',sqrt(abs(dot_product(bjk(i,:),F%base(gst+1:gst+n,i))))
            ENDDO

            write(*,*) 'bjk'
            call PrintMatrix(bjk)

!           Polar decomposition of b_j_k = U V^T. The new basis is in U
            call SolveWithSVD(svals,bjk,U,VT)

!!!
!            write(*,*) 'U'
!            call PrintMatrix(U)
!            write(*,*) 'VT'
!            call PrintMatrix(VT)
!!!
            call MatrixMult(VT,.TRUE.,U,.TRUE.)
!            write(*,*) 'New basis: U <- U*VT'
!            call PrintMatrix(VT)

!           Construct improved F
            IF (SIZE(VT,1).ne.n) THEN
               write(*,*) 'n = ',n,'; SIZE(U,1) = ',SIZE(U,1)
               call AbortWithError('U: wrong # of basis fxns')
            ENDIF
            IF (SIZE(VT,2).ne.rF) &
               call AbortWithError('U: wrong rank')
            F%base(gst+1:gst+n,1:rF)=VT(1:n,1:rF)
            deallocate(bjk,svals,U,VT)

            write(*,*) 'F coefs'
            rnorm=0
            DO i=1,rF
               F%coef(i)=1.d0
               call NewCPvec(v,F%nbas,1)
               call GenCopyWtoV(v,F,1,1,i,i)
               F%coef(i)=PRODVV(v,G)
               call FlushCPvec(v)
               rnorm=rnorm+F%coef(i)**2
               write(*,*) 'koef: ',i,F%coef(i)
            ENDDO
            write(*,*) 'rnorm = ',rnorm
            write(*,*) '||G-F|| = ',calc_FmG(G,F)

!           Check coefs of F for NaN values resulting from zero
!           division. If there are any, restart ALS without updating
            DO i=1,rF
               IF (F%coef(i).ne.F%coef(i)) THEN
                  write(*,*) 'reduc_ALS(): NaN on update; itn = ',itn
                  call FlushCPvec(F)
                  call GetRandomCPvec(F,G%nbas,rF)
                  update=.FALSE.
                  GOTO 76
               ENDIF
            ENDDO

            gst=gst+n
            kp=k
         enddo  ! loop over k
      ENDDO  ! loop over iterations

      deallocate(PS,PSk,PSkm1)

      write(*,*) 'Final F:'
      call TrimZeros(F)
      call ordre(F)
      call PrintCPvec(F)

      call AbortWithError('Done with TSVD')

      end subroutine reduc_TSVD

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine reduc_BIG(G,F,rF,nitn,rederr)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Receives G (represented in reduced form) and F (trial vector to be
! reduced), and approximates G by F using ...

      implicit none
      TYPE (CPvec), INTENT(INOUT) :: G
      TYPE (CPvec), INTENT(OUT) :: F
      TYPE (CPvec) :: H,Ht
      real*8, intent(inout) :: rederr
      integer, intent(in)   :: rF,nitn
      real*8, allocatable :: BB(:,:),U(:,:),VT(:,:),svals(:)
      real*8  :: rnorm,cuttol
      integer :: rG,ndim,i,j,id,ir,imod,k,info,gst,itn,kp,ncomp,nrk

!     Set parameters
      rG=SIZE(G%coef)
      ndim=SIZE(G%nbas)

      IF (rG.le.rF) THEN
         call CopyWtoV(F,G)
         RETURN
      ENDIF

!      write(*,*) 'Original vector (G)'
!      call NORMBASE(G)
!      call ordre(G)
!      call PrintCPvec(G)

!     Construct the BB matrix and weight using coefs
!      allocate(BB(rG,rG))
!      call MultOutCoef(G)
!      call CONSTBBTOT(G,BB)

!      write(*,*) 'BB matrix'
!      call PrintMatrix(BB)

!     Use SVD on the BB matrix to identify the most important terms
!      call SolveWithSVD(svals,BB,U,VT,rF)
!      DEALLOCATE(BB)

!      write(*,*) 'singular values (sqrts)'
!      DO i=1,SIZE(svals)
!         write(*,*) i,sqrt(svals(i))
!      ENDDO
!      write(*,*) 'U matrix'
!      call PrintMatrix(U)

!     Reconstruct the CP-vec, compressing by removing components that
!     are smaller than eps*largest_sval
!      cuttol=eps*svals(1)
!      ncomp=1
!      DO i=2,SIZE(svals)
!         IF (abs(svals(i)).lt.cuttol) EXIT
!         ncomp=i
!      ENDDO
!      nrk=min(rF,ncomp)

!      write(*,*) 'New rank is',nrk

!     Build F from successive rank-1 approximations
!      call NewCPvec(F,G%nbas,nrk)
!      DO i=1,nrk
!         call CopyWtoV(H,G)
!         H%coef(:)=H%coef(:)*U(:,i)
!         DO j=1,rG
!            IF (H%coef(j).lt.0.d0) THEN
!               H%coef(j)=abs(H%coef(j))
!               H%base(1:H%nbas(1),j)=-H%base(1:H%nbas(1),j)
!            ENDIF
!         ENDDO
!         write(*,*) 'Heres H:'
!         call NORMBASE(H)
!         call PrintCPvec(H)
!         call GetRandomCPvec(Ht,G%nbas,1)
!         call reduc_ALS(H,Ht,4*nitn,rederr)
!         F%coef(i)=Ht%coef(1)
!         F%base(:,i)=Ht%base(:,1)
!         call FlushCPvec(Ht)
!         call FlushCPvec(H)
!      ENDDO

      call NewCPvec(F,G%nbas,rF)
      call CopyWtoV(H,G)
      DO i=1,rF
         call GetRandomCPvec(Ht,G%nbas,1)
         call reduc_ALS(H,Ht,nitn,rederr)
         F%coef(i)=Ht%coef(1)
         F%base(:,i)=Ht%base(:,1)
         call SUMVECVEC(H,1.d0,Ht,-1.d0)
         call FlushCPvec(Ht)
      ENDDO
      call FlushCPvec(H)


!      write(*,*) 'New Vector (F)'
!      call NORMBASE(F)
!      call ordre(F)
!      call PrintCPvec(F)

!     Calculate ||F-G|| after final step if requested
      IF (printredn) THEN
         rederr=calc_FmG(G,F)
      ENDIF
!      call AbortWithError('done')

      end subroutine reduc_BIG

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

! This scrap is where 'rederr' is computed fast in the ALS routine

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!     Compute ||F-G|| using existing info
      IF (printredn) THEN

!        Restore BB and PS
         call CONSTBBk(F,kp,BBkm1)
         BB=BBmem*BBkm1
         call CONSTPSk(F,G,kp,PSkm1)
         PS=PS*PSkm1

!        Sum over elements of BB and PS
         rederr=PRODVV(G)
         DO i=1,rF
            DO j=1,rF
               rederr=rederr+F%coef(i)*F%coef(j)*BB(i,j)
            ENDDO
            DO j=1,rG
               rederr=rederr-2*F%coef(i)*G%coef(j)*PS(j,i)
            ENDDO
         ENDDO
         rederr=sqrt(abs(rederr))
      ENDIF

! The traditional way to do it instead

!     Calculate ||F-G|| if requested
      IF (printredn) THEN
         rederr=calc_FmG(G,F)
      ENDIF

!     ALS or RID reduction (set NALS=0 to do RID by itself)
!      ELSEIF ((SIZE(G%nbas).eq.2 .and. red2D.eq.'ALS') .or. &
!              (SIZE(G%nbas).gt.2 .and. redND.eq.'ALS')) THEN
!
!        If G is already small enough, skip ALS/RID
!         IF (SIZE(G%coef).le.newrank) THEN
!            rederr=0.d0
!         ELSE
!            badF=0
!           The initial guess is the existing vector F, but if the rank
!           of F is too small then we must generate a new guess
!            IF (SIZE(F%coef).ne.newrank .or. nloop.eq.0) THEN
!               call FlushCPvec(F)
!               call reduc_RID(G,F,newrank)
!            ENDIF
!            DO
!               call reduc_ALS(G,F,abs(nloop))
!               call validate_ALS(F,badF,ok)
!               IF (ok) THEN
!                  EXIT
!               ELSEIF (badF.ge.1 .and. badF.lt.10) THEN
!                  call GetRandomCPvec(F,G%nbas,newrank)
!               ELSE
!                  call reduc_RID(G,F,newrank)
!                  IF (badF.eq.10) EXIT
!               ENDIF
!            ENDDO
!         ENDIF

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine validate_ALS(F,badF,ok)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Checks for ALS errors and destroys F if it is bad

      implicit none
      TYPE (CPvec), INTENT(INOUT) :: F
      integer, intent(inout) :: badF
      logical, intent(inout) :: ok

!     Check for errors and repeat if necessary
      IF (F%coef(1).ne.F%coef(1)) THEN
         call FlushCPvec(F)
         badF=badF+1
         write(*,*) 'badF=',badF
         ok=.FALSE.
         IF (badF.eq.1) write(*,*) 'Error in reduc_ALS(): ',&
                        'switching to random start vector'
         IF (badF.eq.10) write(*,*) 'Error in reduc_ALS(): ',&
                        'using RID reduction and continuing...'
      ELSE
         ok=.TRUE.
         IF (badF.gt.0) THEN
            write(*,*) 'Error in reduc_ALS(): recovery successful'
         ENDIF
      ENDIF

      end subroutine validate_ALS

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine reduc_ALSSR1(G,F,nitn)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Receives G (represented in reduced form) and F (trial vector to be
! reduced), and approximates G by F using alternating least squares.
! The subroutine optimizes F in dimensions k=1,ndim in succession.

      implicit none
      TYPE (CPvec), INTENT(IN)  :: G
      TYPE (CPvec), INTENT(INOUT) :: F
      TYPE (CPvec) :: T,Ts
      integer, intent(in) :: nitn!,rF
      real*8, dimension (:,:), allocatable :: BB,PS,&
      PSk,PSkm1,BBk,BBkm1,BBs,PSs
      real*8  :: valpen,gtmp,oldcoef
      integer :: rF,rG,rrG,ndim,i,j,ir,k,n,itn,kp,gi,gf
      real*8, parameter :: tol=1.d-12

      IF (nitn.eq.0) return

!     Set parameters
      rG=SIZE(G%coef)
      rF=SIZE(F%coef)
      ndim=SIZE(G%nbas)
      valpen=maxval(G%coef)*1.d-15

!      IF (ndim.eq.2) THEN
!         call reduc_ALS2D(G,F,nitn)
!         return
!      ENDIF

      allocate(BB(1,1),BBk(1,1),BBkm1(1,1),BBs(1,1))
      allocate(PS(rG+rF,1),PSk(rG+rF,1),PSkm1(rG+rF,1),PSs(rG,1))

      IF (printredn) THEN
      write(*,*) 'G, to be reduced:'
      call PrintCPvec(G)
      ENDIF

!      call GetRandomCPvec(Ts,G%nbas,1)
      call NewCPvec(T,G%nbas,1)
!      call NewCPvec(F,G%nbas,rF)
!      F%coef=0.d0
!      F%base=0.d0

!     BBTOT(l,l') = Pi_{i=1}^ndim < F_i^l , F_i^l' >
!     PSTOT(l,l') = Pi_{i=1}^ndim < G_i^l , F_i^l' >
!      call CONSTBBTOT(Ts,BBs)
!      call CONSTPSTOT(Ts,G,PSs)

!     Loop over rF rank-1 terms to be computed
      kp=0
      DO i=1,rF
         rrG=rG+i-1

!        Copy original random vector, BB, PS, instead of recomputing
!         call GenCopyWtoV(T,Ts,1,1,1,1)
!         BB=BBs
!         PS(1:rG,:)=PSs(1:rG,:)
!        Add newest element of PS
!         IF (i.gt.1) call CONSTPSTOT(T,F,PS(rG+1:rrG,:))

!        Use rank-1 portion from F as initial guess
         call GenCopyWtoV(T,F,1,1,i,i)
         call CONSTBBTOT(T,BB)
         call CONSTPSTOT(T,G,PS(1:rG,:))
         IF (i.gt.1) call CONSTPSTOT(T,F,PS(rG+1:rrG,:))

!        Loop over ALS iterations
         kp=0
         oldcoef=1.d99
         DO itn=1,nitn

!           Loop over dimension k
            gi=1
            do k=1,ndim

               n=T%nbas(k)
               gf=gi+n-1

      IF (printredn) THEN
               write(*,*) 'BB b4 update i,itn,k = ',i,itn,k
               call PrintMatrix(BB)
               write(*,*) 'PS b4 update i,itn,k = ',i,itn,k
               call PrintMatrix(PS)
      ENDIF

!              Update the BB and PS matrices of the linear system
               call CONSTBBk(T,k,BBk)
               call CONSTPSk(T,G,k,PSk(1:rG,:))
               IF (i.gt.1) call CONSTPSk(T,F,k,PSk(rG+1:rrG,:))
               IF (kp.ne.0) then
                  call CONSTBBk(T,kp,BBkm1)
                  call CONSTPSk(T,G,kp,PSkm1(1:rG,:))
                  IF (i.gt.1) call CONSTPSk(T,F,kp,PSkm1(rG+1:rrG,:))
                  BB=BB*BBkm1/BBk
                  PS(1:rrG,:)=PS(1:rrG,:)*PSkm1(1:rrG,:)/PSk(1:rrG,:)
               ELSE
                  BB=BB/BBk
                  PS(1:rrG,:)=PS(1:rrG,:)/PSk(1:rrG,:)
               ENDIF

      IF (printredn) THEN
               write(*,*) 'BBk used to update: i,itn,k = ',i,itn,k
               call PrintMatrix(BBk)
               write(*,*) 'PSk used to update: i,itn,k = ',i,itn,k
               call PrintMatrix(PSk)
               IF (kp.ne.0) THEN
                  write(*,*) 'BBkm1 i,itn,k = ',i,itn,k
                  call PrintMatrix(BBkm1)
                  write(*,*) 'PSkm1 i,itn,k = ',i,itn,k
                  call PrintMatrix(PSkm1)
               ENDIF
               write(*,*) 'BB after update i,itn,k = ',i,itn,k
               call PrintMatrix(BB)
               write(*,*) 'PS after update i,itn,k = ',i,itn,k
               call PrintMatrix(PS)
      ENDIF

!              Penalty to avoid ill-conditioning (section 3.2, Beykin)
               BB(1,1)=BB(1,1)+valpen

!              Apply the ALS update to T
               T%base(gi:gf,1)=0.d0
               T%coef(1)=0.d0
               do ir=gi,gf
                  do j=1,rG
                     gtmp=G%coef(j)*G%base(ir,j)
                     T%base(ir,1)=T%base(ir,1)+gtmp*PS(j,1)
                  enddo
                  do j=1,i-1
                     gtmp=F%coef(j)*F%base(ir,j)
                     T%base(ir,1)=T%base(ir,1)+gtmp*PS(rG+j,1)
                  enddo
                  T%base(ir,1)=T%base(ir,1)/BB(1,1)
                  T%coef(1)=T%coef(1)+T%base(ir,1)**2
               enddo
!              Normalization
               T%coef(1)=sqrt(abs(T%coef(1)))

      IF (printredn) THEN
         IF (T%coef(1).eq.0.d0) THEN
         write(*,*) 'Uh-ho: coef is zero. This means...'
         call PrintCPvec(T)
         ENDIF
      ENDIF

               T%base(gi:gf,1)=T%base(gi:gf,1)/T%coef(1)

!              Remove penalty on BB after update
               BB(1,1)=BB(1,1)-valpen

      IF (printredn) THEN
               write(*,*) 'New rank-1 CP-vec, T: i,itn,k = ',i,itn,k
               call PrintCPvec(T)
      ENDIF
              IF (T%coef(1).ne.T%coef(1)) THEN
                 write(*,*) 'T, i=',i,' is NaN-ified'
                 call AbortWithError('Reduction is NaN-ified')
              ENDIF

               gi=gi+n
               kp=k
            enddo  ! loop over k

!           Check for convergence on the coefficient
            IF (abs(oldcoef-T%coef(1))/T%coef(1).lt.tol) EXIT
            oldcoef=T%coef(1)

         ENDDO  ! loop over iterations

!        Copy T into F, with sign change
         call GenCopyWtoV(F,T,i,i,1,1)
         call VecSignChange(F,i,i)

      IF (printredn) THEN
         write(*,*) 'F incremented i = ',i
         call PrintCPvec(F)
      ENDIF

      ENDDO  ! loop over i

      call FlushCPvec(T)
      deallocate(BB,BBk,BBkm1,BBs,PS,PSk,PSkm1,PSs)

!     Change back sign of F
      call VecSignChange(F,1,rF)

      IF (printredn) THEN
      write(*,*) 'Final F:'
      call PrintCPvec(F)
      ENDIF

      end subroutine reduc_ALSSR1

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine reduc_SR1(G,F,rF,nitn)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Receives G (represented in reduced form) and F (trial vector to be
! reduced), and approximates G by F using successive rank-1 approx.

      implicit none
      TYPE (CPvec), INTENT(IN)  :: G
      TYPE (CPvec), INTENT(OUT) :: F
      TYPE (CPvec) :: H,Ht
      integer, intent(in)   :: rF,nitn
      real*8  :: rnorm,cuttol
      integer :: rG,i

!     Set parameters
      rG=SIZE(G%coef)

      IF (rG.le.rF) THEN
         call CopyWtoV(F,G)
         RETURN
      ENDIF

!      write(*,*) 'G:'
!      call PrintCPvec(G)

      call NewCPvec(F,G%nbas,rF)
      call CopyWtoV(H,G)
      DO i=1,rF
         call GetRandomCPvec(Ht,G%nbas,1)
         call reduc_ALS(H,Ht,nitn)
!         write(*,*) 'Ht, i=',i
!         call PrintCPvec(Ht)
         call GenCopyWtoV(F,Ht,i,i,1,1)
         call SUMVECVEC(H,1.d0,Ht,-1.d0)
         call FlushCPvec(Ht)
      ENDDO
      call FlushCPvec(H)

!      write(*,*) 'F:'
!      call PrintCPvec(F)

      end subroutine reduc_SR1

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine reduc_topdn(G,ALSerr)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Takes vector G in separated representation as input, and reduces it
! one rank at a time as much as possible (while maintaining accuracy)

      implicit none
      TYPE (CPvec), INTENT(INOUT) :: G
      TYPE (CPvec)  :: F,F1
      real*8, intent(out)  :: ALSerr
      real*8  :: normFmG,oldnorm
      integer :: nrkG,ir,iloop

      nrkG=SIZE(G%coef)

!     If rank is already 1, no reduction needed!
      IF (nrkG.eq.1) THEN
         ALSerr=0.d0
         RETURN
      ENDIF

!     Copy G to F (F is progressively shortened later)
      call NewCPvec(F,G%nbas,nrkG)
      F=G

      DO ir=nrkG-1,1,-1

!        Copy "shortened" F to F1
         call NewCPvec(F1,F%nbas,ir)
         F1%base(:,1:ir)=F%base(:,1:ir)
         F1%coef(1:ir)=F%coef(1:ir)

!        Compute ||F-F1|| before ALS iterations
         normFmG=calc_FmG(F1,F)

!        Iteratively improve F1 with ALS, checking convergence each time
         DO
!           Exit if reduction of F1 converges
            IF (normFmG.lt.eps) EXIT
            oldnorm = normFmG
            call ALS(F,F1)
            normFmG=calc_FmG(F1,F)

!           Slow convergence: run maxiloop extra iterations
            IF (normFmG .gt. 0.5d0*oldnorm) THEN
               DO iloop=1,maxiloop
                  call ALS(F,F1)
               END DO
               normFmG=calc_FmG(F1,F)
            ENDIF

!           Still not converged? Stop running ALS!
            IF (normFmG .gt. 0.5d0*oldnorm) EXIT

         END DO

         IF (normFmG.ge.eps) EXIT

!        If F1 was successfully reduced above, update F
         call ReplaceVwithW(F,F1)
         ALSerr=normFmG

      END DO

      call ReplaceVwithW(G,F)

      end subroutine reduc_topdn

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine reduc_botup(G,ALSerr)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Takes vector G in separated representation as input, and builds a
! reduced test vector one rank at a time to achieve minimum rank (while
! maintaining accuracy)

      implicit none
      TYPE (CPvec), INTENT(INOUT) :: G
      TYPE (CPvec)  :: F,F1
      real*8, intent(out) :: ALSerr
      real*8  :: normFmG,oldnorm
      integer :: nrkG,ir,iloop

      nrkG=SIZE(G%coef)

      call NewCPvec(F,G%nbas,1)

      DO ir=1,nrkG

!        If the rank reaches the original size of G, no need to run ALS
         IF (ir.eq.nrkG) EXIT

!        Copy F into F1, then extend F1 with an element from G
         call NewCPvec(F1,G%nbas,ir)
         IF (ir.gt.1) THEN
            F1%base(:,1:ir-1)=F%base
            F1%coef(1:ir-1)=F%coef
         ENDIF
         F1%base(:,ir)=G%base(:,ir)
         F1%coef(ir)=G%coef(ir)

!        Compute ||F1-G|| before ALS iterations
         normFmG=calc_FmG(F1,G)

!        Iteratively improve F with ALS, checking convergence each time
         DO
!           Exit if reduction of F converges
            IF (normFmG.lt.eps) EXIT
            oldnorm=normFmG
            call ALS(G,F1)
            normFmG=calc_FmG(F1,G)

!           Slow convergence: run maxiloop extra iterations
            IF (normFmG .gt. 0.5d0*oldnorm) THEN
               DO iloop=1,maxiloop
                  call ALS(G,F1)
               ENDDO
               normFmG=calc_FmG(F1,G)
            ENDIF

!           Still not converged? Stop running ALS!
            IF (normFmG .gt. 0.5d0*oldnorm) EXIT

         END DO

!        Update F
         call ReplaceVwithW(F,F1)

!        If F1 was successfully reduced above, quit
         IF (normFmG.le.eps) EXIT

      END DO

!     If G could not be reduced at all, just return it as-is
      IF (ir.eq.nrkG) THEN
         call FlushCPvec(F)
         ALSerr=0.d0
      ELSE
!        Copy F1 into G
         call ReplaceVwithW(G,F)
         ALserr=normFmG
      ENDIF

      end subroutine reduc_botup

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine TestRank(Q,rantd,ranbu)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Performs 'top-down' and 'bottom-up' rank reduction to see if the rank
! can be reduced smaller than the imposed rank

      implicit none
      TYPE (CPblock), INTENT(IN) :: Q
      TYPE (CPvec)   :: v
      integer, allocatable, intent(inout) :: rantd(:),ranbu(:)
      integer :: j,nbloc

      nbloc=SIZE(Q%rank)

      DO j=1,nbloc
         v=GetVfromBlock(Q,j)
         call reduc(v,'td')
         rantd(j)=SIZE(v%coef)
         call FlushCPvec(v)
         v=GetVfromBlock(Q,j)
         call reduc(v,'bu')
         ranbu(j)=SIZE(v%coef)
         call FlushCPvec(v)
      ENDDO

      end subroutine TestRank

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      SUBROUTINE TestCPmatmult(Tmati,symi,Tmatj,symj)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      implicit none
      TYPE (CPvec) :: CPmati,CPmatj,CPmatk1,CPmatk2
      real*8, intent(in)  :: Tmati(:,:),Tmatj(:,:)
      integer, intent(in) :: symi,symj
      real*8, allocatable :: U(:,:),VT(:,:),svals(:)
      real*8, allocatable :: Ttmati(:,:),Ttmatj(:,:),Tmatk(:,:)

      ALLOCATE(Ttmati(SIZE(Tmati,1),SIZE(Tmati,2)))
      ALLOCATE(Ttmatj(SIZE(Tmatj,1),SIZE(Tmatj,2)))
      Ttmati=Tmati
      Ttmatj=Tmatj

      write(*,'(/A/)') "TestCPmatmult: the original matrix, SD-format"
      write(*,'(/A/)') "The original matrix, Tmati:"
      call PrintMatrix(Ttmati)

      write(*,'(/A/)') "The original matrix, Tmatj:"
      call PrintMatrix(Ttmatj)

      call SolveWithSVD(svals,Ttmati,U,VT) 
      call RebuildfromSVD(CPmati,U,svals,VT,SIZE(svals),.TRUE.)
      DEALLOCATE(U,VT,svals)
      write(*,'(/A/)') "CPmati:"
      call PrintCPvec(CPmati)

      call SolveWithSVD(svals,Ttmatj,U,VT)
      call RebuildfromSVD(CPmatj,U,svals,VT,SIZE(svals),.TRUE.)
      DEALLOCATE(U,VT,svals)
      write(*,'(/A/)') "CPmatj:"
      call PrintCPvec(CPmatj)

      write(*,'(/A/)') "Unitary tfm: CPmatk=CPmati^T*CPmatj*CPmati"
      call CPMatMatProd(CPmatj,.FALSE.,CPmati,.FALSE.,CPmatk1)
      call CPMatMatProd(CPmati,.TRUE.,CPmatk1,.FALSE.,CPmatk2)
      call PrintCPvec(CPmatk2)

      write(*,'(/A/)') "Transformed matrix, Tmatk:"
      call CP2DtoMat(CPmatk2,Tmatk) 
      call PrintMatrix(Tmatk)
      call FlushCPvec(CPmatk2)

      write(*,'(/A/)') "Can Tmatk be compressed? Doing SVD...:"
      call SolveWithSVD(svals,Tmatk,U,VT)
      call RebuildfromSVD(CPmatk2,U,svals,VT,SIZE(svals),.TRUE.)
      DEALLOCATE(U,VT,svals)
      call PrintCPvec(CPmatk2)


      call FlushCPvec(CPmati)
      call FlushCPvec(CPmatj)
      call FlushCPvec(CPmatk1)
      call FlushCPvec(CPmatk2)

      DEALLOCATE(Ttmati,Ttmatj,Tmatk)

      END SUBROUTINE TestCPmatmult

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine BuildRandomBlock(Q)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Fills a block with orthonormalized random vectors

      implicit none
      TYPE (CPblock), INTENT(INOUT) :: Q
      TYPE (CPvec)  :: v
      integer       :: ib,nbloc

      nbloc=SIZE(Q%rank)

      write(*,*) 'Generating block of random vectors...'

!     Build initial (rank=1) block from normalized random vectors
      do ib=1,nbloc
         call GetRandomCPvec(v,Q%nbas,1)
         call NORMCOEF(v)
!        copy v to Q
         call PutVinBlock(v,Q,ib)
         call FlushCPvec(v)
      enddo

!     Orthogonalize via Gram-Schmidt
      write(*,*) 'Gram Schmidt orthogonalization...'

      call GRAMORTHO(Q)

      end subroutine BuildRandomBlock

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine GRAMORTHOa(Q)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Gram-Schmidt orthogonalizes a block of CP-format vectors
! Note: a call to the reduction subroutine is made here
! This version does not increase the maximum rank of Q

      implicit none
      TYPE (CPvec), INTENT(INOUT) :: Q(:)
      TYPE (CPvec)  :: v
      integer :: i,j,nbloc
      real*8  :: vivj

      nbloc=size(Q)

!     Normalize the first vector
      call NORMCOEF(Q(1))

!     Loop through the remaining vectors
!     for each, project out all preceding vectors
      do i=2,nbloc
!        Normalize i-th vector
         call NORMCOEF(Q(i))
         call GetZeroCPvec(v,Q(i)%nbas)

!        Project out vectors preceding Q(i)
         do j=1,i-1
!           Q(i) <- Q(i) - <Q(i),Q(j)>*Q(j)
            vivj=PRODVV(Q(i),Q(j))
            call SUMVECVEC(v,1.d0,Q(j),vivj)
         enddo
         call SUMVECVEC(Q(i),1.d0,v,-1.d0)
         call FlushCPvec(v)

!        Reduce, normalize Q(i)
         call reduc(Q(i),'fr')
         call NORMCOEF(Q(i))
      enddo

      end subroutine GRAMORTHOa

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine GetLCEigenFxna(v,Q,QHQ,weights)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Given the eigenvectors (QHQ), the CP-format vectors (in lan), build a
! linear combination of eigenfunctions weighed by 'weights'. 
! No reduction or normalization is done here.

      implicit none
      TYPE (CPvec), INTENT(IN)  :: Q(:)
      TYPE (CPvec), INTENT(OUT) :: v
      real*8, intent(in) :: QHQ(:,:)
      real*8, intent(in) :: weights(:)
      integer :: i,j,n,rk
      real*8  :: fac

      n=SIZE(QHQ,1)
      call GetZeroCPvec(v,Q(1)%nbas)
      DO j=1,n
         fac=0.d0
         DO i=1,n
            fac=fac+weights(i)*QHQ(j,i)
         ENDDO
         call SUMVECVEC(v,1.d0,Q(j),fac)
      ENDDO

      end subroutine GetLCEigenFxna

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine PRODHVo(F,G,H,ishift,Eshift)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Applies matrix-vector product H*F = G, where H is the Hamiltonian and
! F and G are vectors, all of which are in CP-format

      implicit none
      TYPE (CPvec), INTENT(IN)    :: F,H
      TYPE (CPvec), INTENT(INOUT) :: G
      TYPE (CPvec) :: V
      integer, intent(in) :: ishift
      real*8, intent(in)  :: Eshift
      real*8, allocatable :: vtmp(:),htmp(:,:)
      integer :: i,j,k,l,nrkF,nrkH,ndof,gdim,gstart,mdim,mstart,sym
      real*8  :: rnorm,rnorm1,t1,t2

      IF (.NOT. MVP_SETUP) call InitializePRODHVModule()

      call CPU_TIME(t1)

!     Set parameters
      nrkF=SIZE(F%coef) ! rank of F
      nrkH=SIZE(H%coef) ! rank of H
      ndof=SIZE(F%nbas) ! # modes

      call NewCPvec(V,F%nbas,nrkF)
      call GetZeroCPvec(G,F%nbas)

      DO k=1,nrkH
!        V <- F
         V%base=F%base
         V%coef=F%coef
         DO j=1,ndof
            gdim=V%nbas(j)
            mdim=H%nbas(j)
            gstart=0
            mstart=0
            IF (j.gt.1) THEN
               DO l=2,j
                  gstart=gstart+V%nbas(l-1)
                  mstart=mstart+H%nbas(l-1)
               ENDDO
            ENDIF
            ALLOCATE(vtmp(gdim))
!           Get the operator matrix in stored-diagonal form ('htmp')
            call Vec2Dmat(H%base(mstart+1:mstart+mdim,k),&
                          htmp,gdim,gdim,sym)
            DO i=1,nrkF
               vtmp=V%base(gstart+1:gstart+gdim,i)
               call hop(vtmp,htmp,gdim,sym)
               rnorm=sqrt(dot_product(vtmp,vtmp))
               rnorm1=1/rnorm
               vtmp=vtmp*rnorm1
               V%coef(i)=V%coef(i)*rnorm
               V%base(gstart+1:gstart+gdim,i)=vtmp
            ENDDO
            DEALLOCATE(vtmp,htmp)
         ENDDO
         call SUMVECVEC(G,1.d0,V,H%coef(k))
      ENDDO

!     Energy shift if applicable
      IF (ishift.gt.0) THEN
         call SUMVECVEC(G,1.d0,F,-Eshift)
      ELSE IF (ishift.lt.0) THEN
         call SUMVECVEC(G,-1.d0,F,Eshift)
      ENDIF

      call CPU_TIME(t2)
      mvp_time=mvp_time+t2-t1

      end subroutine PRODHVo

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine hopold(vec,Hmat,vdim,gdim,ndim,sym)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Applies an operator matrix to a vector in sum-of-products (not CP)
! format, as needed for mode combination
! This subroutine assumes that Hmat is symmetric 

      implicit none
      real*8, dimension(:,:), allocatable, intent(in)  :: Hmat
      real*8, dimension(:), allocatable, intent(inout) :: vec
      real*8, dimension(:), allocatable :: vectmp
      integer, intent(in) :: vdim,gdim,ndim,sym
      integer :: mp,hdim,P,gv,n,nt,g,gt,j,j1,j2,jv,v

!     mp = 'modulo P': 0 if even/no sym, 1 if odd sym
      mp=gdim-SIZE(Hmat,1)

      IF (mp.ne.0 .and. mp.ne.1) THEN
         write(*,*) 'hdim = ',SIZE(Hmat,1),', gdim = ',gdim
         CALL AbortWithError('Error in hop(): H,psi size mismatch')
      ENDIF
      hdim=SIZE(Hmat,2)

      ALLOCATE(vectmp(SIZE(vec)))
      vectmp=0.d0

      gv=vdim*gdim
      DO n=1,ndim
         nt=(n-1)*gv
         DO g=1,gdim
            gt=nt+(g-1)*vdim
            DO j=1,hdim
               IF (sym.eq.0 .or. sym.eq.1) THEN
                  j1=g-1+2*(j-1)+mp
               ELSE
                  j1=g+j-2  ! g-1+j-1
               ENDIF
               IF (j1.lt.gdim) THEN
                  jv=nt+j1*vdim
                  DO v=1,vdim
                     vectmp(v+gt)=vectmp(v+gt)+vec(v+jv)*Hmat(g,j)
                  ENDDO
               ENDIF
               IF (j.eq.1 .and. mp.eq.0) CYCLE
               IF (sym.eq.0 .or. sym.eq.1) THEN
                  j2=g-1-2*(j-1)-mp
               ELSE
                  j2=g-j  ! g-1-(j-1)
               ENDIF
               IF (j2.ge.0) THEN
                  jv=nt+j2*vdim
                  DO v=1,vdim
                     vectmp(v+gt)=vectmp(v+gt)+vec(v+jv)*Hmat(j2+1,j)
                  ENDDO
               ENDIF
            ENDDO
         ENDDO
      ENDDO

      vec=vectmp

      DEALLOCATE(vectmp)

      end subroutine hopold

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine SUMVECVEC_ABC(F,G,H)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Sums F and G in separated representation
! returns H with rank being the sums of the ranks of F and G
! F and G are not changed

      implicit none
      TYPE (CPvec), INTENT(IN)  :: F,G
      TYPE (CPvec), INTENT(OUT) :: H
      integer :: nrkF,nrkG,nrkH,ndof

      IF (.NOT.CHECKNBAS(F,G)) THEN
         write(*,*) 'Error: base dimensions of F and G do not match'
         CALL AbortWithError('Error in SUMVECVEC_ABC()')
      ENDIF

      nrkF=SIZE(F%coef)
      nrkG=SIZE(G%coef)
      ndof=SIZE(F%nbas)

!     If one of the two terms is zero, it is replaced by the other
      if ((nrkF.eq.1).and.(F%coef(1).eq.(0.d0))) then
         nrkH=nrkG
         call NewCPvec(H,F%nbas,nrkH)
         H%coef=G%coef
         H%base=G%base
      else if ((nrkG.eq.1).and.(G%coef(1).eq.(0.d0))) then
         nrkH=nrkF
         call NewCPvec(H,F%nbas,nrkH)
         H%coef=F%coef
         H%base=F%base
      else  ! General case
         nrkH=nrkF+nrkG
         call NewCPvec(H,F%nbas,nrkH)
         H%coef(1:nrkF)=F%coef(1:nrkF)
         H%coef(nrkF+1:nrkF+nrkG)=G%coef(1:nrkG)
         H%base(:,1:nrkF)=F%base(:,1:nrkF)
         H%base(:,nrkF+1:nrkF+nrkG)=G%base(:,1:nrkG)
!        Rearrange the components in decreasing order
         call ordre(H)
      endif

      end subroutine SUMVECVEC_ABC

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine SUMVECVECro(F,Ffac,G,Gfac)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Sums Ffac*F and Gfac*G in separated representation
! The summed vector replaces F; G is unchanged

      implicit none
      TYPE (CPvec), INTENT(INOUT) :: F
      TYPE (CPvec), INTENT(IN)    :: G
      TYPE (CPvec)  :: H
      real*8, intent(in) :: Ffac,Gfac
      integer, allocatable :: nbas(:)
      integer :: nrkF,nrkG,ndof
      real*8  :: t1,t2

      IF (.NOT. MVV_SETUP) call InitializeMVV()
      call CPU_TIME(t1)

      IF (.NOT.CHECKNBAS(F,G)) THEN
         write(*,*) 'Error: base dimensions of F and G do not match'
         CALL AbortWithError('Error in SUMVECVEC()')
      ENDIF

      nrkF=SIZE(F%coef)
      nrkG=SIZE(G%coef)
      ndof=SIZE(F%nbas)
      ALLOCATE(nbas(ndof))
      nbas=F%nbas

!     If one of the two terms is zero, it is replaced by the other
      IF ((nrkF.eq.1).and.(F%coef(1).eq.(0.d0))) then
!        Copy G into H
         call NewCPvec(H,nbas,nrkG)
         H%coef=abs(Gfac)*G%coef
         IF (Gfac.ge.0.d0) THEN
!           Positive Gfac: simply copy Gbase
            H%base=G%base
         ELSE
!           Negative Gfac: copy first mode in Gbase with sign change...
            H%base(1:nbas(1),:)=-G%base(1:nbas(1),:)
!           ...then copy the remaining modes if more than 1 mode
            IF (ndof.gt.1) &
            H%base(nbas(1)+1:,:)=G%base(nbas(1)+1:,:)
         ENDIF

      ELSE IF ((nrkG.eq.1).and.(G%coef(1).eq.(0.d0))) then
!        Copy F into H
         call NewCPvec(H,nbas,nrkF)
         H%coef=abs(Ffac)*F%coef
         IF (Ffac.ge.0.d0) THEN
!           Positive Ffac: simply copy Fbase
            H%base=F%base
         ELSE
!           Negative Ffac: copy first mode in Fbase with sign change...
            H%base(1:nbas(1),:)=-F%base(1:nbas(1),:)
!           ...then copy the remaining modes if more than 1 mode
            IF (ndof.gt.1) &
            H%base(nbas(1)+1:,:)=F%base(nbas(1)+1:,:)
         ENDIF

!     General case
      ELSE
!        H is used temporarily to store Ffac*F + Gfac*G
         call NewCPvec(H,nbas,nrkF+nrkG)

!        Copy F into H
         H%coef(1:nrkF)=abs(Ffac)*F%coef(1:nrkF)
         IF (Ffac.ge.0.d0) THEN
!           Positive Ffac: simply copy Fbase
            H%base(:,1:nrkF)=F%base(:,1:nrkF)
         ELSE
!           Negative Ffac: copy first mode in Fbase with sign change...
            H%base(1:nbas(1),1:nrkF)=-F%base(1:nbas(1),1:nrkF)
!           ...then copy the remaining modes if more than 1
            IF (ndof.gt.1) &
            H%base(nbas(1)+1:,1:nrkF)=F%base(nbas(1)+1:,1:nrkF)
         ENDIF

!        Copy G into H
         H%coef(nrkF+1:nrkF+nrkG)=abs(Gfac)*G%coef(:)
         IF (Gfac.ge.0.d0) THEN
!           Positive Gfac: simply copy Gbase
            H%base(:,nrkF+1:nrkF+nrkG)=G%base(:,:)
         ELSE
!           Negative Gfac: copy first mode in Gbase with sign change...
            H%base(1:nbas(1),nrkF+1:nrkF+nrkG)=&
           -G%base(1:nbas(1),:)
!           ...then copy the remaining modes if more than 1
            IF (ndof.gt.1) &
               H%base(nbas(1)+1:,nrkF+1:nrkF+nrkG)=&
               G%base(nbas(1)+1:,:)
         ENDIF

      ENDIF

!     Rearrange the components in decreasing order
      call FlushCPvec(F)
      call ordre(H,F)
      call FlushCPvec(H)

      DEALLOCATE(nbas)

      call CPU_TIME(t2)
      svv_time=svv_time+t2-t1

      end subroutine SUMVECVECro

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      TYPE CPblock
         REAL*8, ALLOCATABLE  :: base(:,:,:), coef(:,:)
         INTEGER, ALLOCATABLE :: rank(:),nbas(:)
      END TYPE CPblock

      INTERFACE CHECKNBAS
                MODULE PROCEDURE CHECKNBASvv
                MODULE PROCEDURE CHECKNBASvQ
                MODULE PROCEDURE CHECKNBASQQ
      END INTERFACE

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      FUNCTION CHECKNBASvQ(v,Q)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Checks nbas of 2 CP-format vectors to make sure they are the same

      IMPLICIT NONE
      TYPE (CPblock), INTENT(IN) :: Q
      TYPE (CPvec), INTENT(IN)   :: v
      LOGICAL :: CHECKNBASvQ
      INTEGER :: ndof,i

      CHECKNBASvQ=.TRUE.

      IF (SIZE(v%nbas).ne.SIZE(Q%nbas)) THEN
         CHECKNBASvQ=.FALSE.
      ELSE
         DO i=1,SIZE(v%nbas)
            IF (v%nbas(i).ne.Q%nbas(i)) THEN
               CHECKNBASvQ=.FALSE.
               EXIT
            ENDIF
         ENDDO
      ENDIF

      END FUNCTION CHECKNBASvQ

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      FUNCTION CHECKNBASQQ(Q1,Q2)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Checks nbas of 2 CP-format vectors to make sure they are the same

      IMPLICIT NONE
      TYPE (CPblock), INTENT(IN) :: Q1,Q2
      LOGICAL :: CHECKNBASQQ
      INTEGER :: ndof,i

      CHECKNBASQQ=.TRUE.

      IF (SIZE(Q1%nbas).ne.SIZE(Q2%nbas)) THEN
         CHECKNBASQQ=.FALSE.
      ELSE
         DO i=1,SIZE(Q1%nbas)
            IF (Q1%nbas(i).ne.Q2%nbas(i)) THEN
               CHECKNBASQQ=.FALSE.
               EXIT
            ENDIF
         ENDDO
      ENDIF

      END FUNCTION CHECKNBASQQ

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      FUNCTION GetVfromBlock(Q,k)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!     Extract a CP-vector from the block

      IMPLICIT NONE
      TYPE (CPblock)      :: Q
      TYPE (CPvec)        :: GetVfromBlock
      INTEGER, INTENT(IN) :: k

      ALLOCATE(GetVfromBlock%base(SIZE(Q%base,1),Q%rank(k)))
      ALLOCATE(GetVfromBlock%coef(Q%rank(k)))
      ALLOCATE(GetVfromBlock%nbas(SIZE(Q%nbas)))
      GetVfromBlock%base(:,:)=Q%base(:,1:Q%rank(k),k)
      GetVfromBlock%coef(:)=Q%coef(1:Q%rank(k),k)
      GetVfromBlock%nbas=Q%nbas

      END FUNCTION GetVfromBlock

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      SUBROUTINE PutVinBlock(v,Q,k)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!     Places CP-vector v into the k-th position in Q, overwriting the 
!     vector previously there

      IMPLICIT NONE
      TYPE (CPblock)           :: Q
      TYPE (CPvec), INTENT(IN) :: v
      INTEGER, INTENT(IN) :: k
      INTEGER             :: nrkv,i

      nrkv=SIZE(v%coef)

      IF (SIZE(v%nbas).ne.SIZE(Q%nbas)) THEN
         write(*,*) 'Error: v and Q have different numbers of DOFs'
         write(*,*) 'SIZE(v%nbas)=',SIZE(v%nbas),'SIZE(Q%nbas)=',&
         SIZE(Q%nbas)
         CALL AbortWithError('Error in PutVinBlock()')
      ENDIF
      DO i=1,SIZE(v%nbas)
         IF (v%nbas(i).ne.Q%nbas(i)) THEN
            write(*,*) 'Error: v and Q have different base structures'
            write(*,*) 'i=',i,'v%nbas(i)=',v%nbas(i),'Q%nbas(i)=',&
                       Q%nbas(i)
            CALL AbortWithError('Error in PutVinBlock()')
         ENDIF
      ENDDO

!     zero the k-th column of Q
      Q%base(:,:,k)=0.d0
      Q%coef(:,k)=0.d0

!     copy v into Q
      Q%base(:,1:nrkv,k)=v%base(:,:)
      Q%coef(1:nrkv,k)=v%coef(:)
      Q%rank(k)=nrkv

      END SUBROUTINE PutVinBlock

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      SUBROUTINE NewCPblock(Q,nbas,maxrnk,nblock)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!     Initializes a new block vector in CP-format

      IMPLICIT NONE
      TYPE (CPblock)      :: Q
      INTEGER, INTENT(IN) :: maxrnk,nblock
      INTEGER, ALLOCATABLE, INTENT(IN) :: nbas(:)
      INTEGER :: nrdim,ndof,i

      IF (maxrnk.lt.1) THEN
         write(*,*) 'Error: maxrnk must be at least 1!'
         call AbortWithError('Error in NewCPblock()')
      ENDIF

!     Determine how the base is arranged from 'nbas', which holds the
!     number of basis functions for each DOF
      ndof=0
      nrdim=0
      DO i=1,SIZE(nbas)
         IF (nbas(i).lt.1) EXIT
         nrdim=nrdim+nbas(i)
         ndof=ndof+1
      ENDDO

      IF (ndof.lt.1) THEN
         write(*,*) 'Error: no degrees of freedom!'
         call AbortWithError('Error in NewCPblock()')
      ENDIF

      ALLOCATE(Q%base(nrdim,maxrnk,nblock),Q%coef(maxrnk,nblock))
      ALLOCATE(Q%rank(nblock),Q%nbas(ndof))
      Q%nbas(1:ndof)=nbas(1:ndof)

      END SUBROUTINE NewCPblock

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine PrintCPBlock(Q)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!     Prints out CP-format block

      implicit none
      TYPE (CPblock), INTENT(IN) :: Q
      integer :: ib,ir,idof,ibf,inr,nbloc
      character*64 :: frmt

      nbloc=SIZE(Q%rank)

      do ib=1,nbloc
         write(frmt,'(A,I0,A)') '(A,X,',Q%rank(ib),'f17.12)'
         write(*,'(/A,I0,A,I0,A)') 'Vector (',ib,'/',nbloc,')'
         write(*,frmt) ' Vcoef =',(Q%coef(ir,ib),ir=1,Q%rank(ib))
         write(frmt,'(A,I0,A)') '(2(I4),X,',Q%rank(ib),'f17.12)'
         inr=1
         do idof=1,SIZE(Q%nbas)
            do ibf=1,Q%nbas(idof)
               write(*,frmt) idof,ibf,&
                             (Q%base(inr,ir,ib),ir=1,Q%rank(ib))
               inr=inr+1
            enddo
         enddo
      enddo

      end subroutine PrintCPBlock

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      SUBROUTINE FlushCPblock(Q)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!     Disposes CP-format block vector

      IMPLICIT NONE
      TYPE (CPblock) :: Q

      IF (ALLOCATED(Q%base)) DEALLOCATE(Q%base)
      IF (ALLOCATED(Q%coef)) DEALLOCATE(Q%coef)
      IF (ALLOCATED(Q%rank)) DEALLOCATE(Q%rank)
      IF (ALLOCATED(Q%nbas)) DEALLOCATE(Q%nbas)

      END SUBROUTINE FlushCPblock

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine GetPrimitiveOperVec(vec,n,p)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Gets the coefficients for x^p expanded in harmonic oscillator basis
! up to order n-1: x^p = SUM_{i=0,n-1} c_i <x^p|phi_i(x)>

      implicit none
      TYPE (ChebObj) :: chb
      integer, intent(in) :: p,n
      real*8, allocatable, intent(out) :: vec(:)
      real*8, allocatable :: dummy(:)
      real*8 :: L,fL,intold
      real*8, parameter :: tol=1.d-12
      integer :: i,j,ist,ncheb

      ALLOCATE(vec(n))

!     KEO case: exit without generating operator vec
      IF (p.lt.0) THEN
         vec=0.d0
         RETURN
      ENDIF

      vec=0.d0
      ist=mod(p,2)+1

      DO i=ist,n,2

!        Find the limits of integration, [-L,L]
!        Initialize L as the harmonic oscillator classical turning
!        point and increase until |x^p*phi_i(x)| is less than tol
         L=sqrt(2*i-1.d0)
         DO
           fL=L**p*HObasisfxn(i-1,L)
           IF (abs(fL).lt.tol) EXIT
           L=L+1.d0
         ENDDO

!        Initialize integral |x^p*phi_i(x)| with small Chebyshev basis
         ncheb=2
         call NewChebObject(chb,ncheb,-L,L,'e','fin')
         DO j=1,ncheb+1
            chb%fpt(j)=chb%mpt(j)**p*HObasisfxn(i-1,chb%mpt(j))
         ENDDO
         call ChebCalculus(chb,0,dummy)

!        Integrate with increasing basis size until integral converges
         DO
!            write(*,*) ncheb,chb%defint
            intold=chb%defint
            call FlushChebObject(chb)
            ncheb=2*ncheb
            call NewChebObject(chb,ncheb,-L,L,'e','fin')
            DO j=1,ncheb+1
               chb%fpt(j)=chb%mpt(j)**p*HObasisfxn(i-1,chb%mpt(j))
            ENDDO
            call ChebCalculus(chb,0,dummy)
            IF (abs((intold-chb%defint)/chb%defint).lt.tol) EXIT
         ENDDO
!         write(*,*) ncheb,chb%defint
         vec(i)=chb%defint
         call FlushChebObject(chb)
!         write(*,*)
      ENDDO

!      write(*,'(/A,I0/)') 'Converged vec: x^',p
!      DO i=1,n
!         write(*,*) i,vec(i)
!      ENDDO
!      write(*,*)

      end subroutine GetPrimitiveOperVec

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine UpdateOperVec(imode,Q,X)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Computes X*Q, transforming the vector representation of X into the 
! eigenbasis

      implicit none
      TYPE (OperMat), INTENT(INOUT) :: X
      TYPE (CPvec), INTENT(IN) :: Q(:)
      integer, intent(in) :: imode
      real*8, allocatable :: XQ(:)
      integer :: i,j,nbloc,gdim,gst,gi,gf,nrk

!     Set parameters
      nbloc=SIZE(Q)
      gdim=Q(1)%nbas(imode)
      gst=0
      IF (imode.gt.1) THEN
         DO i=2,imode
            gst=gst+Q(1)%nbas(i-1)
         ENDDO
      ENDIF
      gi=gst+1
      gf=gst+gdim

      ALLOCATE(XQ(nbloc))
      XQ=0.d0

!     Calculate  coef_i = <Q_i|Op>
      DO i=1,nbloc
         nrk=SIZE(Q(i)%coef)
         DO j=1,nrk
            XQ(i)=XQ(i)+&
                  Q(i)%coef(j)*dot_product(Q(i)%base(gi:gf,j),X%vec)
         ENDDO
      ENDDO

!     Replace the operator vec
      DEALLOCATE(X%vec)
      ALLOCATE(X%vec(nbloc))
      X%vec=XQ
      DEALLOCATE(XQ)

      end subroutine UpdateOperVec

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine reduc_SVDbALT(G,ALSerr)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Reduction using SVD (2D system only); the 'b' algorithm avoids
! multiplying out the CP-format array by using QR decomposition, and
! performs SVD on a smaller matrix. This is faster if nbas(1)*nbas(2)
! is large (>~1600)

      implicit none
      TYPE (CPvec), INTENT(INOUT) :: G
      TYPE (CPvec)  :: F
      real*8, allocatable :: M(:,:),svals(:)
      real*8, allocatable :: Qu(:,:),Qw(:,:),X(:,:),Y(:,:)
      real*8, intent(out) :: ALSerr
      integer :: nr,nc,nrk,ncomp,i,j,ku,kw,s2,e2
      real*8  :: cuttol

      nr=G%nbas(1)
      nc=G%nbas(2)
      nrk=SIZE(G%coef)

      IF (printredn) THEN
         call NewCPvec(F,G%nbas,SIZE(G%coef))
         F=G
      ENDIF

!     Separate G into 2 mode-dependent matrices
      CALL MultOutCoef(G)

!     QR decomposition of U and W
      ku=MIN(nr,nrk)
      kw=MIN(nc,nrk)
      s2=nr+1
      e2=nr+kw
      CALL QRdecompALT(Qu,G%base(1:nr,:))
      CALL QRdecompALT(Qw,G%base(s2:,:))

!     U <- U*W^T (product of two 'R' matrices from QR-decomposition)
      CALL MatrixMult(G%base(1:ku,1:nrk),.FALSE.,&
                      G%base(s2:e2,1:nrk),.TRUE.,M)

!     SVD of U: U=X*svals*Y^T
      CALL SolveWithSVD(svals,M,X,Y,0)
      DEALLOCATE(M)

!     New basis sets 
      CALL MatrixMult(Qu,.FALSE.,X,.FALSE.)
      CALL MatrixMult(Qw,.FALSE.,Y,.TRUE.)
      DEALLOCATE(X,Y)

!     Reconstruct the CP-vec, compressing by removing components that
!     are smaller than eps*largest_sval
      cuttol=eps*svals(1)
      ncomp=1
      DO i=2,SIZE(svals)
         IF (abs(svals(i)).lt.cuttol) EXIT
         ncomp=i
      ENDDO
      nrk=min(nr,nc,newrank,ncomp)

      call RebuildfromSVD(G,Qu,svals,Qw,nrk,.FALSE.)

!     Calculate ||F-G|| before replacing G with F, if requested
      IF (printredn) THEN
         ALSerr=calc_FmG(G,F)
         call FlushCPvec(F)
      ENDIF

      DEALLOCATE(Qu,Qw,svals)

      end subroutine reduc_SVDbALT

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine reduc_OPT(G,rF,nitn,ALSerr)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Receives G (represented in reduced form) and F (trial vector to be
! reduced), and approximates G by F using CPOPT, as described in
! Acar, Dunlavy and Kolda, J. Chemometrics 25 (2011) 67-86.
 
      implicit none
      TYPE (CPvec), INTENT(INOUT) :: G
      TYPE (CPvec) :: F
      integer, intent(in)   :: rF,nitn
      real*8, intent(inout) :: ALSerr
      real*8, allocatable   :: dFa(:),dFb(:),dFc(:)
      real*8  :: fx1,fx,fxnew,den,tmp,tst,gg,dgg,gam
      integer :: rG,ndim,nfbas,nvec,i,j,k,gi,gf,itn
      real*8, parameter :: ftol=2.d-8
      real*8, parameter :: gtol=1.d-8
      real*8, parameter :: PREC=1.d-16
      logical :: test=.TRUE.

      rG=SIZE(G%coef)
      ndim=SIZE(G%nbas)
      nfbas=SIZE(G%base,1)
      nvec=rF*nfbas

!     If G is already small enough, no need to reduce
      IF (rG.le.rF .or. nitn.eq.0) THEN
         ALSerr=0.d0
         RETURN
      ENDIF

!     Derivative arrays dFa <-> xi, dFb <-> g, and dFc <-> h from NR
      allocate(dFa(nvec),dFb(nvec),dFc(nvec))

!!! TEST
      IF (test) write(*,'(/A/)') 'CP-OPT'

      call NORMBASE(G)
      call ordre(G)
      call DistributeCoef(G)

      call NewCPvec(F,G%nbas,rF)
      F%coef(:)=G%coef(:rF)
      F%base(:,:)=G%base(:,:rF)
!      call reduc_RID(F,ALSerr)


!     Initialize F as a random vector, but normalize and set coefs
!     to 1.0 to avoid repeated multiplications of F%coef(i)*F%base(:,i)
!      call GetRandomCPvec(F,G%nbas,rF)
!      call NORMBASE(F)
!      F%coef=1.d0

!!! TEST
      IF (test) THEN
         write(*,*) 'G, the CP-vec to fit'
         call PrintCPvec(G)
         write(*,*)
         write(*,*) 'F, at the start of OPT'
         call PrintCPvec(F)
         write(*,*)
      ENDIF

!     First component of objective function (compute only once)
      fx1=0.5*PRODVV(G)
!     Evaluate the objective function and gradient
      call getCPfxn(G,F,fx1,fx,dFa,.TRUE.)

!!! TEST
      IF (test) THEN
         write(*,*) 'rG = ',rG,'; rF = ',rF
         write(*,*) 'Initial red error: fx1 = ',fx1,'; fx = ',fx
         write(*,*) 'Initial gradient :'
         call PrintVector(dFa)
      ENDIF

!     Initialize recurrence arrays 
      dFb=-dFa
      dFc=dFb
      dFa=dFc

!     Main loop over iterations
      DO itn=1,nitn

!!! TEST 
         IF (TEST) write(*,*) 'Opt cycle:',itn

!        Line minimization along gradient
         call dlinminCP(G,F,fx1,fx,fxnew,dFa)

!        Converged if function value stops changing
         IF (2*abs(fxnew-fx) .le. ftol*(abs(fxnew)+abs(fx)+PREC)) THEN
!!! TEST
            IF (TEST) write(*,*) 'OPT converged on ftol'
            EXIT
         ENDIF

         fx=fxnew

!        Check gradient. Converged if close enough to zero
         tst=0.d0
         den=max(fx,1.d0)
         k=1
         DO i=1,rF
            DO j=1,nfbas
               tmp=abs(dFa(k))*max(abs(F%base(j,i)),1.d0)/den
               IF (tmp.gt.tst) tst=tmp
               k=k+1
            ENDDO
         ENDDO

         IF (tst.lt.gtol) THEN
!!! TEST
            IF (TEST) write(*,*) 'OPT converged on gtol'
            EXIT
         ENDIF

!        CG updates
         gg=0.d0
         dgg=0.d0
         DO i=1,nvec
!            gg=gg+dFb(i)**2 ! FR or PR
            gg=gg+dFc(i)*(dFa(i)+dFb(i))  ! HS or DY
            dgg=dgg+(dFa(i)+dFb(i))*dFa(i) ! PR or HS
!            dgg=dgg+dFa(i)**2 ! FR or DY
         ENDDO

!        Another zero gradient condition
         IF (gg.eq.0.d0) THEN 
!!! TEST
            IF (TEST) write(*,*) 'OPT converged on gg'
            EXIT
         ENDIF

!        Update the gradients
         gam=dgg/gg
         dFb=-dFa
         dFc=dFb+gam*dFc
         dFa=dFc

      ENDDO  ! loop over itns

!!! TEST
      IF (TEST) THEN
         write(*,*)
         write(*,*) 'Final gradient:'
         call PrintVector(dFa)
         ALSerr=calc_FmG(G,F)
         write(*,*) 'ALSerr (old way) = ',ALSerr
      ENDIF

      deallocate(dFa,dFb,dFc)

!     Replace G with reduced vector F
      call ReplaceVwithW(G,F)
!     ALSerr: what we've been minimizing all along!
      ALSerr=sqrt(abs(2*fx))

!!! TEST
      IF (TEST) THEN
         write(*,*) 'ALSerr (obj fxn) = ',ALSerr
!         call AbortWithError('Done with OPT cycles')
      ENDIF

      end subroutine reduc_OPT

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine PISTfilterU(v,w,H,bounds,ccoef)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Applies spectrally-transformed Hamiltonian to vector v: H_st*v = w
! This uses the "upward" Clenshaw recursion

      implicit none
      TYPE (CPvec), INTENT(IN)  :: v
      TYPE (CPvec), INTENT(OUT) :: w
      TYPE (CPvec), INTENT(IN)  :: H(:,:)
      TYPE (CPvec), ALLOCATABLE :: vb(:)
      real*8, intent(in)  :: bounds(2)
      real*8, intent(in)  :: ccoef(:)
      real*8  :: av,df
      integer :: i,ncheb

!     Set parameters
      ncheb=SIZE(ccoef)
      av=0.5d0*(bounds(2)+bounds(1))
      df=2.d0/(bounds(2)-bounds(1))

      ALLOCATE(vb(ncheb))

!      write(*,*) 'Here is v'
!      call PrintCPvec(v)

!     Initialize the recurrence with T_0(x) and T_1(x)
      call CopyWtoV(vb(1),v)
      call PRODHV(vb(1),w,H,1,av)
      call reduc(vb(2),w)
      call NORMBASE(vb(2))
      call VecScalarMult(vb(2),df,1,SIZE(vb(2)%coef))

!     Compute higher order Chebyshev polynomials
      DO i=3,ncheb
         call PRODHV(vb(i-1),w,H,1,av)
         call SUMVECVEC(w,2.d0*df,vb(i-2),-1.d0)
         call reduc(vb(i),w)
         call NORMBASE(vb(i))
         call FlushCPvec(w)
      ENDDO

!     Build the Chebyshev expansion and place into w
!     The c0 coefficient is multiplied by 0.5
      call VecScalarMult(vb(1),0.5d0,1,SIZE(vb(1)%coef))
      call SUMLCVEC(w,vb,ccoef)

      DEALLOCATE(vb)

      end subroutine PISTfilterU

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine PISTfilterU2(v,w,H,bounds,ccoef)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Applies spectrally-transformed Hamiltonian to vector v: H_st*v = w
! This uses the "upward" Clenshaw recursion

      implicit none
      TYPE (CPvec), INTENT(IN)  :: v
      TYPE (CPvec), INTENT(OUT) :: w
      TYPE (CPvec), INTENT(IN)  :: H(:,:)
      TYPE (CPvec) :: vo,vn,vt,vv
      real*8, intent(in)  :: bounds(2)
      real*8, intent(in)  :: ccoef(:)
      real*8  :: av,df,rq
      integer :: i,ncheb

!     Set parameters
      ncheb=SIZE(ccoef)
      av=0.5d0*(bounds(2)+bounds(1))
      df=2.d0/(bounds(2)-bounds(1))

!      write(*,*) 'Here is v'
!      call PrintCPvec(v)

!     Initialize the recurrence with T_0(x) and T_1(x)
      call CopyWtoV(vo,v)
      call PRODHV(vo,vt,H,1,av)
      call reduc(vn,vt)
      call NORMBASE(vn)
      call VecScalarMult(vn,df,1,SIZE(vn%coef))
      call FlushCPvec(vt)

!     w = 0.5*c_0*T_0 + c_1*T_1
!     There should be at least 2 coefs in ccoef
      call CopyWtoV(w,vn)
      call SUMVECVEC(w,ccoef(2),vo,0.5d0*ccoef(1))

!     Compute higher order Chebyshev polynomials
      DO i=3,ncheb
!        Chebyshev recursion: vt = 2x*vn - vo
         call PRODHV(vn,vt,H,1,av)
         call SUMVECVEC(vt,2.d0*df,vo,-1.d0)
         call ReplaceVwithW(vo,vn)
         call reduc(vn,vt)
         call NORMBASE(vn)
         call FlushCPvec(vt)

!        Add c_i*vn to the sum
         call SUMVECVEC(w,1.d0,vn,ccoef(i))

         call reduc(vv,w)
         call NORMCOEF(vv)
         rq=RayleighQuotient(vv,H)
         write(*,*) 'ncheb = ',i,'; RQ = ',rq
         call FlushCPvec(vv)
      ENDDO

      end subroutine PISTfilterU2

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      function SpecTfmFxn(par,x)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Spectral transform function. Fill in the function and parameters of
! your choice

      implicit none
      real*8, intent(in) :: x,par(8)
      real*8 :: SpecTfmFxn

!      IF (x.lt.par(1)) THEN
!         SpecTfmFxn=0.d0
!      ELSE

!     Chebyshev Cardinal function (pick node near Etarget)
!      SpecTfmFxn=ChebCard(INT(par(8)),167,(x-par(3))/par(4),.FALSE.)

!     Exponential function f(x) = exp(-alpha*(x-Etarget))
!      SpecTfmFxn=exp(par(2)*(par(1)-x))

!     Gaussian f(x) = exp(alpha*(x-Etarget)**2)
!     par(1)=Etarget, par(2)=alpha 
!      SpecTfmFxn=exp(-par(6)*(x-par(1))**2)

!     Lorentzian f(x) = 1/(1+alpha*(x-Etarget)**2)
      SpecTfmFxn=1.d0/(1.d0+par(7)*(x-par(1))**2)

!     Power function f(x) = 1/alpha*((x-Etarget)**2)
!      SpecTfmFxn=1.d0/par(2)/(x-par(1))**2

!     Power function f(x) = 1/alpha*(x-Etarget)
!      SpecTfmFxn=1.d0/(x-par(1))

!     Quadratic function f(x) = 1-alpha*(x-Etarget)**2
!      SpecTfmFxn=1.d0-par(5)*(x-par(1))**2

!      ENDIF

      end function SpecTfmFxn

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine GetSTElist(nev,npow,bounds,Etarget,Elist)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Gets the Chebyshev coefs for the spectral transform function defined
! over [bounds(1),bounds(2)]

      implicit none
      TYPE (ChebObj)      :: chb
      integer, intent(in) :: npow,nev
      real*8, intent(in)  :: Etarget,bounds(2)
      real*8, allocatable, intent(out) :: Elist(:)
      integer :: i
      real*8  :: avdf(2),xt,pN,Emin,Emax
      real*8, parameter :: PI=3.141592653589793,tol=1.d-16

      pN=PI/npow

!     Error checking
      IF (nev.gt.npow) &
         call AbortWithError('GetSTElist(): nev > npow')
      IF (Etarget.lt.bounds(1) .or. Etarget.gt.bounds(2)) &
         call AbortWithError('GetSTElist(): Etarget exceeds bounds')

!     Map Etarget [Emin,Emax] --> [-1,1] --> [PI,0]
      avdf=averdif(bounds)
      xt=acos(mapx(Etarget,avdf,'fin',.TRUE.))

!     Compute the limits of sampling window
      Emin=xt+0.5*(nev-1)*pN
      Emax=xt-0.5*(nev-1)*pN

!     Shift limits it they exceed [PI,0] on one end or the other
      IF (Emin.gt.PI) THEN
         Emin=PI
         Emax=Emin-(nev-1)*pN
      ELSEIF (Emax.lt.0.d0) THEN
         Emax=0.d0
         Emin=Emax+(nev-1)*pN
      ENDIF

!     Put sample energies every PI/npow radians
      write(*,*) 'Energy sampling list'
      ALLOCATE(Elist(nev))
      DO i=1,nev
         write(*,*) i,cos(Emin-(i-1)*pN),&
                    mapx(cos(Emin-(i-1)*pN),avdf,'fin',.FALSE.)
         Elist(i)=cos(Emin-(i-1)*pN)
      ENDDO
      write(*,*)

      end subroutine GetSTElist

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine getCPfxn(G,F,fx1,fx,dF,getGrad)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Gets the CPOPT objective function ||G-F||, including the PSEC and BB
! arrays. fx1 = ||G|| is given on input to avoid recomputing it. Set
! getGrad to .TRUE., to compute the gradient, which is stored in dF

      implicit none
      TYPE (CPvec), INTENT(IN) :: G,F
      real*8, intent(inout) :: dF(:)
      real*8, intent(in)    :: fx1
      real*8, intent(out)   :: fx
      logical, intent(in)   :: getGrad
      real*8, allocatable   :: BB(:,:),BBk(:,:),BBkm1(:,:)
      real*8, allocatable   :: PS(:,:),PSk(:,:),PSkm1(:,:)
      real*8  :: valpen
      integer :: rF,rG,ndim,nvec,i,j,k,l,gi,gf,ri,re

      rF=SIZE(F%coef)
      rG=SIZE(G%coef)
      ndim=SIZE(F%nbas)
      nvec=SIZE(F%base,1)

!     Penalty to avoid bad conditioning
      valpen=maxval(G%coef)*1.d-15

      ALLOCATE(BB(rF,rF),PS(rG,rF))

!     BBTOT(l,l') = Pi_{i=1}^ndim < F_i^l , F_i^l' >
!     PSTOT(l,l') = Pi_{i=1}^ndim < G_i^l , F_i^l' >
      call CONSTBBTOT(F,BB)
      call CONSTPSTOT(F,G,PS)

!     Evaluate the objective function:
!     fx = ||G-F|| = ||G||**2 - 2<G,F> + ||F||**2
      fx=fx1
      DO i=1,rF
         DO j=1,rF
            fx=fx+0.5*F%coef(i)*F%coef(j)*BB(i,j)
         ENDDO
         DO j=1,rG
            fx=fx-F%coef(i)*G%coef(j)*PS(j,i)
         ENDDO
      ENDDO

!     Gradient calculation if requested
      IF (getGrad) THEN

         ALLOCATE(BBk(rF,rF),BBkm1(rF,rF),PSk(rG,rF),PSkm1(rG,rF))

         dF=0.d0

!        Loop over dimension k
         gi=1
         DO k=1,ndim
            gf=gi+F%nbas(k)-1

!           Update BB and PS matrices
            call CONSTBBk(F,k,BBk)
            call CONSTPSk(F,G,k,PSk)
            if (k.gt.1) then
               call CONSTBBk(F,k-1,BBkm1)
               call CONSTPSk(F,G,k-1,PSkm1)
               BB=BB*BBkm1/BBk
               PS=PS*PSkm1/PSk
            else
               BB=BB/BBk
               PS=PS/PSk
            endif

!           Add penalty to avoid ill-conditioning (section 3.2, Beykin)
!            do i=1,rF
!               BB(i,i)=BB(i,i)+valpen
!            enddo

!           Fill the gradient array for the k-th DOF
            ri=gi
            re=gf
            DO i=1,rF
               DO j=1,rF
                  dF(ri:re)=dF(ri:re)+F%coef(j)*F%base(gi:gf,j)*BB(j,i)
               ENDDO
               DO j=1,rG
                  dF(ri:re)=dF(ri:re)-G%coef(j)*G%base(gi:gf,j)*PS(j,i)
               ENDDO
               ri=ri+nvec
               re=re+nvec
            ENDDO

!           Remove penalty on BB before updating for the next DOF
!            do i=1,rF
!               BB(i,i)=BB(i,i)-valpen
!            enddo

            gi=gf+1
         ENDDO  ! loop over k
         DEALLOCATE(BBk,BBkm1,PSk,PSkm1)
      ENDIF

      DEALLOCATE(BB,PS)

      end subroutine getCPfxn

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine dlinminCP(G,F,fx1,fx,fxnew,dF)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Returns F which minimizes ||G-F|| along the gradient direction dF.
! See Dlinemethod() in Numerical Recipes, 3rd Ed (2007) p. 519

      implicit none
      TYPE (CPvec), INTENT(INOUT) :: F
      TYPE (CPvec), INTENT(IN)    :: G
      TYPE (CPvec) :: H
      real*8, intent(inout) :: dF(:)
      real*8, allocatable   :: dH(:)
      real*8, intent(in)    :: fx1,fx
      real*8, intent(out)   :: fxnew
      real*8  :: ax,bx,cx,rnorm
      integer :: rF

      rF=SIZE(F%coef)

      rnorm=1/sqrt(abs(dot_product(dF(:),dF(:))))
      dF=rnorm*dF

      call NewCPvec(H,F%nbas,rF)
      ALLOCATE(dH(SIZE(dF)))

!     Get the points which bracket the minimum along the line
      CALL CPbracket(G,F,H,fx1,fx,dF,dH,ax,bx,cx)
!     Minimize along the line
      CALL CPminimize(G,F,H,fx1,dF,dH,ax,bx,cx,fxnew)

!     Update F and dF
      call ReplaceVwithW(F,H)
      dF=dH
      DEALLOCATE(dH)

      end subroutine dlinminCP

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine CPfxonLine(G,F,dF,x,fx1,H,fh,dH,lgrad,getdH)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Given CP-vector F which approximates CP-vector G, this computes
! H = F + x*dF and evaluates fH = ||G-H||
! If getdH is set to .TRUE., the gradient d||G-H||/dH is returned in dH,
! and PROJ(dH,dF) is returned in lgrad.

      implicit none
      TYPE (CPvec), INTENT(IN)    :: G,F
      TYPE (CPvec), INTENT(INOUT) :: H
      real*8, intent(in)    :: dF(:)
      real*8, intent(inout) :: dH(:)
      real*8, intent(in)    :: x,fx1
      real*8, intent(out)   :: fh,lgrad
      logical, intent(in)   :: getdH
      integer :: i,ri,re,rF,nfbas

      rF=SIZE(F%coef)
      nfbas=SIZE(F%base,1)

!     Obtain H by shifting F along the gradient by x*dF
      H%coef=1.d0
      ri=1
      DO i=1,rF
         re=ri+nfbas-1
         H%base(:,i)=F%base(:,i)+x*dF(ri:re)
         ri=re+1
      ENDDO

!     Evaluate ||G-H|| (and possibly dH)
      call getCPfxn(G,H,fx1,fh,dH,getdH)

!     Compute the line gradient (projection of dH onto dF)
      IF (getdH) lgrad=dot_product(dF(:),dH(:))

      end subroutine CPfxonLine

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine CPbracket(G,F,H,fx1,fx,dF,dH,ax,bx,cx)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Given an original function value, ||G-F||, and gradient, this brackets
! the minimum along the gradient direction
! See Bracketmethod() in Numerical Recipes, 3rd Ed (2007) p. 498

      implicit none
      TYPE (CPvec), INTENT(IN)    :: G,F
      TYPE (CPvec), INTENT(INOUT) :: H
      real*8, intent(in)    :: dF(:)
      real*8, intent(inout) :: dH(:)
      real*8, intent(in)    :: fx1,fx
      real*8, intent(out)   :: ax,bx,cx
      real*8, parameter :: GRAT=1.61803398875
      real*8, parameter :: GLIM=100.
      real*8, parameter :: smallnr=1.d-18
      real*8 :: q,r,u,fu,ulim,fa,fb,fc,lgrad
      integer :: fcalls

      write(*,*) '    CPbracket()'
      fcalls=0

!     ax and bx are the first 2 points of the bracketing trio
      ax=0.d0
      bx=1.d0 !-6 !/MAX(abs(MAXVAL(dF)),abs(MINVAL(dF)))
      fa=fx

      call CPfxonLine(G,F,dF,bx,fx1,H,fb,dH,lgrad,.FALSE.)
      fcalls=fcalls+1

!     Swap a and b if fb > fa
      IF (fb.gt.fa) THEN
         u=ax
         fu=fa
         ax=bx
         fa=fb
         bx=u
         fb=fu
      ENDIF

!     Guess for the third bracketing point
      cx=bx+GRAT*(bx-ax)
      call CPfxonLine(G,F,dF,cx,fx1,H,fc,dH,lgrad,.FALSE.)
      fcalls=fcalls+1

      write(*,*) '      ax,fa,bx,fb,cx,fc : ',ax,fa,bx,fb,cx,fc

!     Refine the bracketing points until they enclose a minimum
      DO
         IF (fb.lt.fc) EXIT  ! Success

!        Parabolic extrapolation to guess next point
         r=(bx-ax)*(fb-fc)
         q=(bx-cx)*(fb-fa)
         u=bx-((bx-cx)*q-(bx-ax)*r)/(2*SIGN(MAX(abs(q-r),smallnr),q-r))
         ulim=bx+GLIM*(cx-bx)

!        Bracketing cx is between b and current cx
         IF ((bx-u)*(u-cx).gt.0.d0) THEN
            call CPfxonLine(G,F,dF,u,fx1,H,fu,dH,lgrad,.FALSE.)
            fcalls=fcalls+1

!           Minimum between bx and cx
            IF (fu.lt.fc) THEN
               ax=bx
               fa=fb
               bx=u
               fb=fu
      write(*,*) '      ax,fa,bx,fb,cx,fc : ',ax,fa,bx,fb,cx,fc
               EXIT

!           Minimum between ax and u
            ELSEIF (fu.gt.fb) THEN
               cx=u
               fc=fu
      write(*,*) '      ax,fa,bx,fb,cx,fc : ',ax,fa,bx,fb,cx,fc
               EXIT
            ENDIF

!           Discard parabolic guess
            u=cx+GRAT*(cx-bx)
            call CPfxonLine(G,F,dF,u,fx1,H,fu,dH,lgrad,.FALSE.)
            fcalls=fcalls+1

!        Bracketing cx between current cx and the max value
         ELSEIF ((cx-u)*(u-ulim).gt.0.d0) THEN
            call CPfxonLine(G,F,dF,u,fx1,H,fu,dH,lgrad,.FALSE.)
            fcalls=fcalls+1

            IF (fu.lt.fc) THEN
                bx=cx
                fb=fc
                cx=u
                fc=fu
      write(*,*) '      ax,fa,bx,fb,cx,fc : ',ax,fa,bx,fb,cx,fc
                u=u+GRAT*(u-bx)
                call CPfxonLine(G,F,dF,u,fx1,H,fu,dH,lgrad,.FALSE.)
                fcalls=fcalls+1
            ENDIF

!        Use maximum permissible value of u to guess next cx
         ELSEIF ((u-ulim)*(ulim-cx).ge.0.d0) THEN
            u=ulim
            call CPfxonLine(G,F,dF,u,fx1,H,fu,dH,lgrad,.FALSE.)
            fcalls=fcalls+1

!        Use Golden Ratio to guess next cx
         ELSE
            u=cx+GRAT*(cx-bx)
            call CPfxonLine(G,F,dF,u,fx1,H,fu,dH,lgrad,.FALSE.)
            fcalls=fcalls+1

         ENDIF
         ax=bx
         fa=fb
         bx=cx
         fb=fc
         cx=u
         fc=fu
      write(*,*) '      ax,fa,bx,fb,cx,fc : ',ax,fa,bx,fb,cx,fc
      ENDDO

      write(*,*) '      function calls in CPbracket() :',fcalls

      end subroutine CPbracket

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine CPminimize(G,F,H,fx1,dF,dH,ax,bx,cx,fmin)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Minimizes function using gradient information via Brent's method. 
! See Dbrent() in Numerical Recipes, 3rd Ed (2007) p. 500

      implicit none
      TYPE (CPvec), INTENT(IN)    :: G,F
      TYPE (CPvec), INTENT(INOUT) :: H
      real*8, intent(in)    :: dF(:)
      real*8, intent(inout) :: dH(:)
      real*8, intent(in)  :: fx1,ax,bx,cx
      real*8, intent(out) :: fmin
      integer, parameter  :: maxit=100
      real*8, parameter   :: smallnr=1.d-16
      real*8, parameter   :: tol=1.0d-12
      real*8 :: a,b,u,v,w,x,xm,fu,fv,fw,fx,du,dv,dw,dx,dd,d1,d2,u1,u2
      real*8 :: tol1,tol2,ee,olde,xmin
      integer :: i,fcalls
      logical :: ok1,ok2

      write(*,*) '    CPminimize()'
      fcalls=0

!     Initializations
      dd=0.d0
      ee=0.d0
      a=MIN(ax,cx)
      b=MAX(ax,cx)
      x=bx
      v=bx
      w=bx

!     Evaluate function and derivative
      call CPfxonLine(G,F,dF,x,fx1,H,fx,dH,dx,.TRUE.)
      fcalls=fcalls+1
      fv=fx
      fw=fx
      dv=dx
      dw=dx

      write(*,*) '      minimizing cycle, x,fx,dx=',0,x,fx,dx

!     Main loop over iterations
      DO i=1,maxit

         xm=0.5d0*(a+b)
         tol1=tol*abs(x)+smallnr
         tol2=2*tol1

!        If next point is close enough to this one, min is converged
         IF (abs(x-xm).le.(tol2-0.5d0*(b-a))) THEN
            fmin=fx
            xmin=x
            EXIT
         ENDIF

         IF (abs(ee).gt.tol1) THEN

            d1=2*(b-a)
            d2=d1

            IF (dw.ne.dx) d1=(w-x)*dx/(dx-dw)
            IF (dv.ne.dx) d2=(v-x)*dx/(dx-dv)

            u1=x+d1
            u2=x+d2

            ok1=((a-u1)*(u1-b).gt.0.d0 .and. dx*d1.le.0.d0)
            ok2=((a-u2)*(u2-b).gt.0.d0 .and. dx*d2.le.0.d0)

            olde=ee
            ee=dd

            IF (ok1.or.ok2) THEN
               IF (ok1.and.ok2) THEN
                  IF (abs(d1).lt.abs(d2)) THEN
                     dd=d1
                  ELSE
                     dd=d2
                  ENDIF
               ELSEIF (ok1) THEN
                  dd=d1
               ELSE
                  dd=d2
               ENDIF
               IF (abs(dd).le.abs(0.5d0*olde)) THEN
                  u=x+dd
                  IF ((u-a).lt.tol2.or.(b-u).lt.tol2) dd=SIGN(tol1,xm-x)
               ELSE  ! pick segment based on derivative sign
                  IF (dx.ge.0.d0) THEN
                     ee=a-x
                  ELSE
                     ee=b-x
                  ENDIF
                  dd=0.5d0*ee
               ENDIF
            ELSE  ! pick segment based on derivative sign
               IF (dx.ge.0.d0) THEN
                  ee=a-x
               ELSE
                  ee=b-x
               ENDIF
               dd=0.5d0*ee
            ENDIF

         ELSE  ! pick segment based on derivative sign
            IF (dx.ge.0.d0) THEN
               ee=a-x
            ELSE
               ee=b-x
            ENDIF
            dd=0.5d0*ee
         ENDIF

         IF (abs(dd).ge.tol1) THEN
            u=x+dd
!           Evaluate function, return in fu
            call CPfxonLine(G,F,dF,u,fx1,H,fu,dH,du,.TRUE.)
            fcalls=fcalls+1
         ELSE
            u=x+SIGN(tol1,dd)
!           Evaluate function, return in fu
            call CPfxonLine(G,F,dF,u,fx1,H,fu,dH,du,.TRUE.)
            fcalls=fcalls+1

            IF (fu.gt.fx) THEN  ! Converged: can only go uphill
               xmin=x
               fmin=fx
               EXIT
            ENDIF
         ENDIF

!        Update x and f values
         IF (fu.le.fx) THEN
            IF (u.ge.x) THEN
               a=x
            ELSE
               b=x
            ENDIF
            v=w
            fv=fw
            dv=dw
            w=x
            fw=fx
            dw=dx
            x=u
            fx=fu
            dx=du
      write(*,*) '      minimizing cycle, x,fx,dx=',i,x,fx,dx
         ELSE
            IF (u.lt.x) THEN
               a=u
            ELSE
               b=u
            ENDIF
            IF (fu.le.fw .or. w.eq.x) THEN
               v=w
               fv=fw
               dv=dw
               w=u
               fw=fu
               dw=du
            ELSEIF (fu.lt.fv .or. v.eq.x .or. v.eq.w) THEN
               v=u
               fv=fu
               dv=du
            ENDIF
         ENDIF
      ENDDO

      write(*,*) '      function calls in CPminimize():',fcalls

      end subroutine CPminimize

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine BlockCG(v,H,npow,Eshift)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Applies Hamiltonian (H-E)^npow*v to vector v
! The ishift parameter controls the shifting

      implicit none
      TYPE (CPvec), INTENT(INOUT) :: v
      TYPE (CPvec), INTENT(IN) :: H(:,:)
      TYPE (CPvec) :: p,r,w,x
      integer, intent(in) :: npow
      real*8, intent(in)  :: Eshift
      integer :: i
      real*8  :: a,b,pvvr

      write(*,'(/A/)') 'Blockrecursa:'

      write(*,*) 'i, RQ(x) = ',0,RayleighQuotient(v,H)


!     Initializations
      call PRODHV(v,r,H,1,Eshift)
      call SUMVECVEC(r,-1.d0,v,1.d0)
      call reduc(r)
      call CopyWtoV(p,r)
      pvvr=PRODVV(r)

      do i=1,npow
         call PRODHV(p,w,H,1,Eshift)

         a=pvvr/PRODVV(p,w)
         call SUMVECVEC(r,1.d0,w,-a)
         call reduc(r)

         b=1.d0/pvvr
         pvvr=PRODVV(r)
         b=b*pvvr

         call SUMVECVEC(p,b,r,1.d0)
         call reduc(p)
         call FlushCPvec(w)

         call SUMVECVEC(v,1.d0,p,a)
         write(*,*) 'i, RQ(x) = ',i,RayleighQuotient(v,H),&
         '; ranks: r,p,x = ',SIZE(r%coef),SIZE(p%coef),SIZE(v%coef)
      enddo

      call reduc(v)
      call NORMCOEF(v)

      end subroutine BlockCG

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine ALS_INV(H,F,nitn,ishift,Eshift)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! ALS guided inverse iteration. Given CP-format Hamiltonian H and vector
! F, F is iteratively refined using inverse iteration. The final vector 
! has the same rank as initial vector F

      implicit none
      TYPE (CPvec), INTENT(IN)    :: H(:,:)
      TYPE (CPvec), INTENT(INOUT) :: F
      TYPE (CPvec) :: Y,G
      integer, intent(in) :: nitn,ishift
      real*8, intent(in)  :: Eshift
      real*8, dimension (:,:), allocatable :: BB,PS,bjk,IPIV,&
      PSk,PSkm1,BBk,BBkm1,BBmem
      real*8  :: valpen,rnorm,gtmp
      integer :: rG,rF,ndim,i,j,ir,imod,k,l,n,info,gst,itn,kp
      logical :: update

      IF (nitn.eq.0) return

!     Copy F -> Y; compute G using a matrix-vector product
      call CopyWtoV(Y,F)
      call PRODHV(F,G,H,ishift,Eshift)

!     Set parameters
      rG=SIZE(G%coef)
      rF=SIZE(F%coef)
      ndim=SIZE(G%nbas)

!     Update the ALS matrices BB and PS if ndim > 3. For ndim <= 3 it
!     is faster to build BB and PS at each iteration.
!     Building also avoids possible zero division during the update.
      update=.TRUE.
      IF (ndim.le.3)  update=.FALSE.

      allocate(IPIV(rF,rF),BB(rF,rF),BBmem(rF,rF))
      allocate(BBk(rF,rF),BBkm1(rF,rF))
      allocate(PS(rG,rF),PSk(rG,rF),PSkm1(rG,rF))

!     Penalty to avoid bad conditioning
      valpen=maxval(G%coef)*1.d-15

76    continue

!     BB(l,l') = Pi_{i=2}^ndim < F_i^l , F_i^l' >
!     PS(l,l') = Pi_{i=2}^ndim < G_i^l , F_i^l' >
!     If the ALS matrices BB and PS are to be updated, initialize
!     them here with the first DOF removed
      IF (update) THEN
          call CONSTBBk(F,2,BB)
          call CONSTPSk(Y,G,2,PS)
          DO k=3,ndim
             call CONSTBBk(F,k,BBk)
             call CONSTPSk(Y,G,k,PSk)
             BB=BB*BBk
             PS=PS*PSk
          ENDDO
      ENDIF

!     Main loop over ALS iterations
      kp=0
      DO itn=1,nitn

!        Loop over dimension k
         gst=0
         do k=1,ndim
            n=F%nbas(k)

!            write(*,*) 'itn,k=',itn,k,', update PS and BB'

!           Update the BB and PS matrices of the linear system. This
!           also requires copying BBmem <-- BB since LAPACK destroys BB
            IF (update) THEN
               IF (kp.ne.0) then
                  call CONSTBBk(F,k,BBk)
                  call CONSTBBk(F,kp,BBkm1)
                  call CONSTPSk(Y,G,k,PSk)
                  call CONSTPSk(Y,G,kp,PSkm1)
                  BB=BBmem*BBkm1/BBk
                  PS=PS*PSkm1/PSk
               ENDIF
               BBmem=BB

!           Alternatively, build BB and PS from scratch
            ELSE
               kp=mod(k,ndim)+1
               call CONSTBBk(F,kp,BB)
               call CONSTPSk(Y,G,kp,PS)
               DO l=2,ndim-1
                  kp=mod(k+l-1,ndim)+1
                  call CONSTBBk(F,kp,BBk)
                  call CONSTPSk(Y,G,kp,PSk)
                  BB=BB*BBk
                  PS=PS*PSk
               ENDDO
            ENDIF

!           Add penalty to avoid ill-conditioning (section 3.2, Beykin)
            do i=1,rF
               BB(i,i)=BB(i,i)+valpen
            enddo

!            write(*,*) 'itn,k=',itn,k,', build bjk'

!           Calculate b_j_k ( l', nr) (Beylkin, eq. 3.4)
            allocate(bjk(rF,n))
            bjk=0.d0
            do ir=1,n
               imod=gst+ir
               do j=1,rG
                  gtmp=G%coef(j)*G%base(imod,j)
                  do i=1,rF
                     bjk(i,ir)=bjk(i,ir)+gtmp*PS(j,i)
                  enddo
               enddo
            enddo

!            write(*,*) 'itn,k=',itn,k,', solve linear systems'

!           Solve linear system B*c_j_k = b_j_k (eq 3.5)
!           (B includes all inner products except the kth)
!           Use DGETRF for LU factorization + DGETRS to solve system
            call dgetrf(rF,rF,BB,rF,IPIV,info)
            call dgetrs('N',rF,n,BB,rF,IPIV,bjk,rF,INFO)

!            write(*,*) 'itn,k=',itn,k,', construct new F'

!           Construct improved F
            do i=1,rF
               rnorm=sqrt(abs(dot_product(bjk(i,:),bjk(i,:))))
               F%coef(i)=rnorm
               do ir=1,n
                  imod=gst+ir
                  F%base(imod,i)=bjk(i,ir)/rnorm
               enddo
            enddo
            deallocate(bjk)

!            write(*,*) 'itn,k=',itn,k,', normalize F'

!           Normalize the coefficients of F; otherwise the coefficients
!           will overflow after several iterations
            rnorm=1/sqrt(abs(PRODVV(F)))
            F%coef=F%coef*rnorm

!            write(*,*) 'itn,k=',itn,k,', update G'

!           Matrix-vector product on the k-th DOF
            call PRODHV1(F,G,H,k,ishift,Eshift)

!           Check coefs of F for NaN values resulting from zero
!           division. If there are any, restart ALS without updating
            DO i=1,rF
               IF (F%coef(i).ne.F%coef(i)) THEN
                  write(*,*) 'ALS_POW(): NaN on update; itn = ',itn
                  call AbortWithError('ALS_POW crashed')
                  call FlushCPvec(F)
                  call GetRandomCPvec(F,G%nbas,rF)
                  update=.FALSE.
                  GOTO 76
               ENDIF
            ENDDO

            gst=gst+n
            kp=k
         enddo  ! loop over k
      ENDDO  ! loop over iterations

      deallocate(BB,BBmem,BBk,BBkm1,PS,PSk,PSkm1,IPIV)
      call FlushCPvec(G)
      call FlushCPvec(Y)

      end subroutine ALS_INV

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine Schulz(H,Hi)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Computes H^-1 using Schulz iteration applied to H. On entry, H should
! be given as the full matrix rep'n, not the upper triangle i.e. sym = 
! .FALSE.

      implicit none
      TYPE (CPvec), INTENT(IN)  :: H
      TYPE (CPvec), INTENT(OUT) :: Hi
      TYPE (CPvec) :: I,T,T2
      real*8, allocatable  :: tmat(:,:),tmat1(:,:)
      real*8, allocatable  :: tvec(:)
      integer, allocatable :: nbas(:)
      integer :: j,ndof,niter,gi,gf,rH

      write(*,*) 'Schulz'

      niter=15
      ndof=SIZE(H%nbas)
      ALLOCATE(nbas(ndof))
      rH=SIZE(H%coef)

      DO j=1,ndof
         nbas(j)=NINT(sqrt(REAL(H%nbas(j))))
      ENDDO

      call GetIdentityCPMatrix(I,nbas,.FALSE.)

      write(*,*) 'Initial guess'

!     Initial guess: reduce H to rank-1 and invert each little-h
      call CopyWtoV(Hi,H)
      call SetReductionParameters(1,30,1.d-12,.FALSE.,'ALS','ALS')
      call reduc(Hi)
      gi=1
      DO j=1,ndof
         gf=gi+Hi%nbas(j)-1
         call Vec2Mat(Hi%base(gi:gf,1),tmat,nbas(j),nbas(j))
         call MatrixPseudoinverse(tmat,tmat1)
         call Mat2Vec(tvec,tmat1,.FALSE.)
         Hi%base(gi:gf,1)=tvec(1:Hi%nbas(j)) 
         DEALLOCATE(tmat,tmat1,tvec)
         gi=gf+1
      ENDDO
      Hi%coef(1)=1/Hi%coef(1)

      write(*,*) 'The mighty rank-1 approximate inverse, Hi'
      call PrintCPmat(Hi)

      write(*,*) 'Is H*Hi initial = I ?'
      call CPMatMatProd(H,.FALSE.,Hi,.FALSE.,T,nbas,nbas,nbas,nbas)
      call reduc(T)
      call DistributeCoef(T)
      call PrintCPmat(T)
      call FlushCPvec(T)


      call SetReductionParameters(rH,30,1.d-12,.FALSE.,'ALS','ALS')

      DO j=1,niter
         write(*,*) 'Schulz iteration: ',j
!        T = 2 * I - H * HI_j
         call CPMatMatProd(H,.FALSE.,Hi,.FALSE.,T,nbas,nbas,nbas,nbas)
         call SUMVECVEC(T,-1.d0,I,2.d0)
         call reduc(T)
!        Hi_j+1 = Hi_j * T
         call CPMatMatProd(Hi,.FALSE.,T,.FALSE.,T2,nbas,nbas,nbas,nbas)
         call FlushCPvec(T)
         call reduc(Hi,T2)
         call FlushCPvec(T2)
!         write(*,*) 'Hi:'
!         call PrintCPmat(Hi)
      ENDDO

!!!   TEST
      call SetReductionParameters(1,30,1.d-12,.FALSE.,'ALS','ALS')
      write(*,*) 'Is H*Hi final = I ?'
      call CPMatMatProd(H,.FALSE.,Hi,.FALSE.,T,nbas,nbas,nbas,nbas)
      call reduc(T)
      call DistributeCoef(T) 
      call PrintCPmat(T)
      call FlushCPvec(T)
!!!

      end subroutine Schulz

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      PROGRAM FFPESGEN

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Reads force field constants and generates a callable .f90 PES file

      USE ERRORTRAP
      USE UTILS
      USE HAMILSETUP
      USE INPUTFIELDS
      USE CPCONFIG

      implicit none
      TYPE (Configs), ALLOCATABLE :: V(:)
      TYPE (PESpar) :: PES
      character(72) :: partition,frmt
      character(13) :: fn,fname
      integer, allocatable :: modpowr(:,:)
      integer :: u,i,j,k,ndof,ncp,ndf,d(3),t(3)
      real*8  :: t1,t2

      call idate(d)
      call itime(t)
      call CPU_TIME(t1)

      write(*,'(X,A/)') '############################################'
      write(*,*)       '      Force Field PES Generating Program    '
      write(*,*)       '           by Phillip S. Thomas             '
      write(*,*)       '          Version ML2b 03-17-2016           '
      write(*,'(/X,A/)') '############################################'
      write(*,'(X,4(A,I0),2(A,I2.2)/)') 'FFGENPES initialized on ',d(2)&
           ,'/',d(1),'/',d(3),' at ',t(1),':',t(2),':',t(3)

      fname='pesgen.inp'
!     Read the input file
      call ReadPESgenInputFile(PES,fname)

!     Read force constants stored in fX files
      call ReadFFHamiltonian(V,PES%PESname,PES%maxorder,PES%divide)

      partition='!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'//&
                '%%%%%%%%%%%%%%%%%%%%%%'
      write(fn,'(2A)') 'potfunc_',PES%PESname
      write(fname,'(3A)') 'PES_',PES%PESname,'.f90'
      ndof=V(1)%nbas(1)
      ncp=PES%maxorder

      u=LookForFreeUnit()
      open(u,status='unknown',file=fname)

!     Module header
      write(u,'(A/)') partition 
      write(u,'(6X,A,A/)') 'MODULE PES_',PES%PESname
      write(u,'(A)') partition
      write(u,'(A,A/)') '! PES module for ',PES%PESname
      write(u,'(6X,A)') 'implicit none'
      write(fn,'(2A)') 'getndof_',PES%PESname
      write(u,'(6X,3(A,X),I0/)') 'integer, parameter ::',fn,'=',ndof
      write(u,'(6X,A)') 'CONTAINS'

!     Subroutine header
      write(fn,'(2A)') 'potfunc_',PES%PESname
      write(u,'(/A/)') partition
      write(u,'(6X,3A/)') 'function ',fn,'(y)'
      write(u,'(A)') partition
      write(u,'(A,A/)') '! Potential energy function for ',PES%PESname
      write(u,'(6X,A)') 'implicit none'
      write(u,'(6X,A,I0,A)') 'real*8, intent(in) :: y(',ndof,')'
      write(u,'(6X,A,2(I0,A))') 'real*8  :: x('&
                ,ndof,',',ncp,')'
      write(u,'(6X,2A)') 'real*8  :: ',fn
      write(u,'(6X,A)') 'integer :: i,j'
      write(u,'(6X,2(A,I0))') 'integer, parameter :: ndof=',ndof,&
                               ',nord=',ncp

!     Pre-calculating powers of y
      write(u,'(/A)') '!     Pre-calculate powers of y'
      write(u,'(6X,A)') 'DO i=1,ndof'
      write(u,'(9X,A)') 'x(i,1)=y(i)'
      write(u,'(9X,A)') 'DO j=2,nord'
      write(u,'(12X,A)') 'x(i,j)=x(i,j-1)*y(i)'
      write(u,'(9X,A)') 'ENDDO'
      write(u,'(6X,A)') 'ENDDO'

!     The code itself
      write(u,'(/A)') '!     Compute the potential'

      write(u,'(6X,2A)') fn,' = 0.d0 &'
!      write(u,'(6X,2A,ES23.16)') fn,'=',PES%Eshift
      DO k=1,ncp

!        If V(k) is a zero vector, skip
         IF (SIZE(V(k)%coef).eq.1 .and. V(k)%coef(1).eq.0.d0) CYCLE

         DO i=1,SIZE(V(k)%coef)

!           Convert config to product of q(s) to some power(s)
            call DistribModePower(V(k)%qns(i,:),modpowr)
            ndf=SIZE(modpowr,1)

!           Write term to file
            write(frmt,'(A,I0,A)') '(6X,A,f13.6,A,',ndf,&
                                   '(A,I0,A,I0,A),A)'
            write(u,frmt) '+ (',V(k)%coef(i),')',('*x(',modpowr(j,1),&
            ',',modpowr(j,2),')',j=1,ndf),' &'

!            write(frmt,'(A,I0,A)') '(6X,4A,f13.6,A,',ndf,&
!                                   '(A,I0,A,I0,A))'
!            write(u,frmt) fn,'=',fn,'+ (',V(k)%coef(i),')',&
!            ('*x(',modpowr(j,1),',',modpowr(j,2),')',j=1,ndf)

            DEALLOCATE(modpowr)
         ENDDO
      ENDDO

!     Eshift goes at end
      write(u,'(6X,A,ES23.16/)') '+ ',PES%Eshift

!     Stuff at the end
      write(u,'(6X,2A/)') 'end function ',fn
      write(u,'(A/)') partition
      write(u,'(6X,A,A/)') 'END MODULE PES_',PES%PESname
      write(u,'(A)') partition

      close(u)

      DEALLOCATE(V)

      call CPU_TIME(t2)

      write(*,'(/3(X,A))') 'PES routine',fname, 'created successfully!'

      write(*,'(/X,A,f11.2/)') 'FFGENPES total CPU run time (s):',t2-t1

      write(*,'(X,4(A,I0),2(A,I2.2))') 'FFGENPES finished on ',d(2),'/'&
            ,d(1),'/',d(3),' at ',t(1),':',t(2),':',t(3)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      END PROGRAM FFPESGEN

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine ReadPESgenInputFile(pesp,fnm)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!     Reads input file for CP-format code for computing eigenvalues

      implicit none
      TYPE (PESpar), INTENT(OUT) :: pesp
      character(len=13), intent(in) :: fnm
      integer :: u,InpStat

!     Open input file
      u = LookForFreeUnit()
      OPEN(u, FILE=TRIM(ADJUSTL(fnm)), STATUS="OLD", IOSTAT=InpStat)
      IF (InpStat /= 0) THEN
         write(*,*) TRIM(ADJUSTL(fnm)),' not found'
         call AbortWithError("Oh, no! Error reading input file")
      ENDIF

!     list of parameters
!     PES to fit
      read(u,*)
      read(u,*) pesp%PESname
!     maximum number of terms multiplied in the potential
      read(u,*)
      read(u,*) pesp%maxorder
!     Divide constants by degeneracy factors
      read(u,*)
      read(u,*) pesp%divide
!     Shift potential by energy value
      read(u,*)
      read(u,*) pesp%Eshift

      CLOSE(u)

      write(*,'(X,A/)') '********** Input parameters read: ***********'
      write(*,'(X,A,2X,A5)') 'A .f90 module will be made for        :',&
                             pesp%PESname
      write(*,'(X,A,2X,I5)') 'Maximum order of potential  (maxorder):',&
                             pesp%maxorder
      write(*,'(X,A,2X,L5)') 'Divide by degeneracy factors  (divide):',&
                             pesp%divide
      write(*,'(X,A,2X,ES23.16)') &
                'Shift potential by energy     (Eshift):  ',pesp%Eshift
      write(*,'(/X,A)') '*********************************************'

      end subroutine ReadPESgenInputFile

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      function RayleighResidualALT(v,H,eig,j)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Computes the Rayleigh quotient residual for vector v and Hamiltonian H
! v should be normalized using NORMCOEF() before calling

      implicit none
      TYPE (CPvec), INTENT(IN) :: H(:,:)
      TYPE (CPvec), INTENT(IN) :: v
      TYPE (CPvec) :: w
      integer, intent(in) :: j
      real*8, intent(in)  :: eig(:)
      real*8 :: RayleighResidualALT,delta

      IF (SIZE(eig).lt.2) &
         call AbortWithError('RayleighResidualALT(): < 2 eigvals')
      IF (j.lt.1 .or. j.gt.SIZE(eig)) &
         call AbortWithError('RayleighResidualALT(): j out of range')

      IF (j.eq.1) THEN
         delta=abs(eig(2)-eig(1))
      ELSEIF (j.eq.SIZE(eig)) THEN
         delta=abs(eig(j)-eig(j-1))
      ELSE
         delta=MIN(abs(eig(j)-eig(j-1)),abs(eig(j+1)-eig(j)))
      ENDIF

!     w = H*v - eig*v
      call PRODHV(v,w,H,0,0.d0)
      call SUMVECVEC(w,1.d0,v,-eig(j))

!      call reduc(w)

!     Calculate ||w||
      RayleighResidualALT=PRODVV(w)/delta

      call FlushCPvec(w)

      end function RayleighResidualALT

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine ALS_POW2(H,F,nitn,ishift,Eshift)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! ALS guided power method. Given CP-format Hamiltonian H and vector F, F
! is iteratively refined using the power method (H - Eshift*I)*F. The
! final vector has the same rank as initial vector F. This version
! recomputes PSk and bjk from H*F, as needed, to bypass forming the
! "long" G vector, but stores up to 2 rG x rF 'PS' matrices

      implicit none
      TYPE (CPvec), INTENT(IN)    :: H(:,:)
      TYPE (CPvec), INTENT(INOUT) :: F
      integer, intent(in) :: nitn,ishift
      real*8, intent(in)  :: Eshift
      real*8, dimension (:,:), allocatable :: BB,PS,bjk,PSk,BBk,BBmem
      integer, allocatable :: nbas(:)
      real*8  :: valpen,rnorm,gtmp,t1,t2
      integer :: rG,rF,ndim,i,j,ir,imod,k,l,n,info,gst,itn,kp
      logical :: update

      IF (nitn.eq.0) return
      IF (.NOT. ALSHAM_SETUP) call SetupALSHam()

      call CPU_TIME(t1)

!     Set parameters
      ndim=SIZE(F%nbas)
      rF=SIZE(F%coef)
      rG=rF*SIZE(H,1)
      IF (ishift.ne.0) rG=rG+rF

!     Update the ALS matrices BB and PS if ndim > 3. For ndim <= 3 it
!     is faster to build BB and PS at each iteration.
!     Building also avoids possible zero division during the update.
      update=.TRUE.
      IF (ndim.le.3)  update=.FALSE.

      allocate(BB(rF,rF),BBmem(rF,rF),PS(rG,rF))

!     Penalty to avoid bad conditioning
      valpen=maxval(F%coef)*1.d-10

!     BB(l,l') = Pi_{i=2}^ndim < F_i^l , F_i^l' >
!     PS(l,l') = Pi_{i=2}^ndim < G_i^l , F_i^l' >
!     If the ALS matrices BB and PS are to be updated, initialize
!     them here with the first DOF removed
      IF (update) THEN
!         Build BB and PS in series to minimize memory
          call CONSTBBk(F,2,BB)
          ALLOCATE(BBk(rF,rF))
          DO k=3,ndim
             call CONSTBBk(F,k,BBk)
             BB=BB*BBk
          ENDDO
          DEALLOCATE(BBk)

!         Build PS without storing G
          call PRODHV4PS(F,H,PS,2,ishift,Eshift)
          ALLOCATE(PSk(rG,rF))
          DO k=3,ndim
             call PRODHV4PS(F,H,PSk,k,ishift,Eshift)
             PS=PS*PSk
          ENDDO
          DEALLOCATE(PSk)
      ENDIF

!     Main loop over ALS iterations
      kp=0
      DO itn=1,nitn

!        Loop over dimension k
         gst=0
         do k=1,ndim
            n=F%nbas(k)

!           Update the BB and PS matrices of the linear system. This
!           also requires copying BBmem <-- BB since LAPACK destroys BB
            IF (update) THEN
               IF (kp.ne.0) then
                  ALLOCATE(BBk(rF,rF))
                  call CONSTBBk(F,kp,BBk)
                  BB=BBmem*BBk
                  call CONSTBBk(F,k,BBk)
                  BB=BB/BBk
                  DEALLOCATE(BBk)

                  ALLOCATE(PSk(rG,rF))
                  call PRODHV4PS(F,H,PSk,kp,ishift,Eshift)
                  PS=PS*PSk
                  call PRODHV4PS(F,H,PSk,k,ishift,Eshift)
                  PS=PS/PSk
                  DEALLOCATE(PSk)
               ENDIF
               BBmem=BB

!           Alternatively, build BB and PS from scratch
            ELSE
               kp=mod(k,ndim)+1
               call CONSTBBk(F,kp,BB)
               ALLOCATE(BBk(rF,rF))
               DO l=2,ndim-1
                  kp=mod(k+l-1,ndim)+1
                  call CONSTBBk(F,kp,BBk)
                  BB=BB*BBk
               ENDDO
               DEALLOCATE(BBk)

               kp=mod(k,ndim)+1
               call PRODHV4PS(F,H,PS,kp,ishift,Eshift)
               ALLOCATE(PSk(rG,rF))
               DO l=2,ndim-1
                  kp=mod(k+l-1,ndim)+1
                  call PRODHV4PS(F,H,PSk,kp,ishift,Eshift)
                  PS=PS*PSk
               ENDDO
               DEALLOCATE(PSk)
            ENDIF

!           Add penalty to avoid ill-conditioning (section 3.2, Beykin)
            do i=1,rF
               BB(i,i)=BB(i,i)+valpen
            enddo

!           Calculate b_j_k ( l', nr) (Beylkin, eq. 3.4)
            allocate(bjk(rF,n))
            call PRODHV4bjk(F,H,PS,bjk,k,ishift,Eshift)

!           Solve linear system B*c_j_k = b_j_k (eq 3.5)
!           (B includes all inner products except the kth)
!           Use DGETRF for LU factorization + DGETRS to solve system
            allocate(BBk(rF,rF))
            call dgetrf(rF,rF,BB,rF,BBk,info)
            call dgetrs('N',rF,n,BB,rF,BBk,bjk,rF,INFO)
            deallocate(BBk)

!           Construct improved F
            do i=1,rF
               rnorm=sqrt(abs(dot_product(bjk(i,:),bjk(i,:))))
               F%coef(i)=rnorm
               do ir=1,n
                  imod=gst+ir
                  F%base(imod,i)=bjk(i,ir)/rnorm
               enddo
            enddo
            deallocate(bjk)

            call CPU_TIME(t2)
            alsham_time=alsham_time+t2-t1

!           Normalize the coefficients of F after each complete mat-vec
!           to avoid overflow, which can occur after several iterations
            IF (k.eq.ndim) THEN
               rnorm=1/sqrt(abs(PRODVV(F)))
               F%coef=F%coef*rnorm
            ENDIF

            call CPU_TIME(t1)

!           Check coefs of F for NaN values resulting from zero
!           division. If there are any, restart ALS without updating
            DO i=1,rF
               IF (F%coef(i).ne.F%coef(i)) THEN
                  write(*,*) 'ALS_POW2(): NaN on update; itn = ',itn
                  call AbortWithError('ALS_POW2 crashed')
               ENDIF
            ENDDO

            gst=gst+n
            kp=k
         enddo  ! loop over k
      ENDDO  ! loop over iterations

      deallocate(BB,BBmem,PS)

      call CPU_TIME(t2)
      alsham_time=alsham_time+t2-t1

      end subroutine ALS_POW2

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine PRODHV4PS(F,H,PSk,idof,ishift,Eshift)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Applies matrix-vector product to compute <F,H*F>, where H is the 
! Hamiltonian and F is a CP vectors. The rF x rF*rH matrix of overlaps
! is returned. This subroutine applies the matrix-vector product only to 
! the 'idof'-th DOF. PSk must be allocated on entry.

      implicit none
      TYPE (CPvec), INTENT(IN) :: H(:,:)
      TYPE (CPvec), INTENT(IN) :: F
      integer, intent(in)   :: idof,ishift
      real*8, intent(in)    :: Eshift
      real*8, intent(inout) :: PSk(:,:)
      real*8, allocatable   :: T(:)
      integer :: i,j,k,ik,l,rF,rG,rH,rFH,gi,gf
      real*8  :: t1,t2

      IF (.NOT. MVP_SETUP) call InitializePRODHVModule()

!     Set parameters
      rF=SIZE(F%coef) ! rank of F
      rH=SIZE(H,1)    ! rank of H
      rFH=rF*rH
      rG=rFH
      IF (ishift.ne.0) rG=rG+rF

!     Error checking
      IF (rG.ne.SIZE(PSk,1)) THEN
         write(*,*) 'rG = ',rG,'; SIZE(PSk,1) = ',SIZE(PSk,1)
         call AbortWithError('PRODHV4PS(): mismatch between rG and PSk')
      ENDIF
      IF (rF.ne.SIZE(PSk,2)) THEN
         write(*,*) 'rF = ',rF,'; SIZE(PSk,2) = ',SIZE(PSk,2)
         call AbortWithError('PRODHV4PS(): mismatch between rF and PSk')
      ENDIF

!     Find the index range for DOF 'idof'
      gi=1
      DO j=1,idof-1
         gi=gi+F%nbas(j)
      ENDDO
      gf=gi+F%nbas(idof)-1

      ALLOCATE(T(F%nbas(idof)))

      PSk=0.d0

!     Loop over terms in H
      ik=1
      DO k=1,rH
!        Loop over terms in F
         DO i=1,rF
            call CPMatOrdVecProd(H(k,idof),F%base(gi:gf,i),T)
!           Dot product <F,H*F>
            DO l=1,rF
               DO j=1,F%nbas(idof)
                  PSk(ik,l)=PSk(ik,l)+F%base(gi+j-1,l)*T(j)
               ENDDO
            ENDDO
            ik=ik+1
         ENDDO
      ENDDO

!     Energy shift if applicable
      IF (ishift.ne.0) THEN
!        The usual case: (H-E*1)*v
         DO i=1,rF
            T(:)=F%base(gi:gf,i)
            IF (idof.eq.1) T(:)=-T(:)
            DO l=1,rF
               DO j=1,F%nbas(idof)
                  PSk(ik,l)=PSk(ik,l)+F%base(gi+j-1,l)*T(j)
               ENDDO
            ENDDO
            ik=ik+1
         ENDDO

!        The rare case: (E*1-H)*v
         IF (idof.eq.1) THEN
            IF (ishift.lt.0) THEN
               PSk=-PSk
            ENDIF
         ENDIF
      ENDIF

      DEALLOCATE(T)

      end subroutine PRODHV4PS

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine PRODHV4bjk(F,H,PS,bjk,idof,ishift,Eshift)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Applies matrix-vector product to compute <F,H*F>, where H is the 
! Hamiltonian and F is a CP vectors. The rF x rF*rH matrix of overlaps
! is returned. This subroutine applies the matrix-vector product only to 
! the 'idof'-th DOF. PSk must be allocated on entry.

      implicit none
      TYPE (CPvec), INTENT(IN) :: H(:,:)
      TYPE (CPvec), INTENT(IN) :: F
      integer, intent(in)   :: idof,ishift
      real*8, intent(in)    :: Eshift
      real*8, intent(in)    :: PS(:,:)
      real*8, intent(inout) :: bjk(:,:)
      real*8, allocatable   :: T(:)
      integer :: i,j,k,ik,l,rF,rG,rH,rFH,gi,gf
      real*8  :: t1,t2

      IF (.NOT. MVP_SETUP) call InitializePRODHVModule()

!     Set parameters
      rF=SIZE(F%coef) ! rank of F
      rH=SIZE(H,1)    ! rank of H
      rFH=rF*rH
      rG=rFH
      IF (ishift.ne.0) rG=rG+rF

!     Error checking
      IF (rG.ne.SIZE(PS,1)) THEN
         write(*,*) 'rG = ',rG,'; SIZE(PS,1) = ',SIZE(PS,1)
         call AbortWithError('PRODHV4bjk(): mismatch between rG and PS')
      ENDIF
      IF (rF.ne.SIZE(PS,2)) THEN
         write(*,*) 'rF = ',rF,'; SIZE(PS,2) = ',SIZE(PS,2)
         call AbortWithError('PRODHV4bjk(): mismatch between rF and PS')
      ENDIF
      IF (rF.ne.SIZE(bjk,1)) THEN
         write(*,*) 'rF = ',rF,'; SIZE(bjk,1) = ',SIZE(bjk,1)
         call AbortWithError('PRODHV4bjk(): mismatch between rF and bjk')
      ENDIF
      IF (F%nbas(idof).ne.SIZE(bjk,2)) THEN
         write(*,*) 'n = ',F%nbas(idof),'; SIZE(bjk,2) = ',SIZE(bjk,2)
         call AbortWithError('PRODHV4bjk(): mismatch between n and bjk')
      ENDIF

!     Find the index range for DOF 'idof'
      gi=1
      DO j=1,idof-1
         gi=gi+F%nbas(j)
      ENDDO
      gf=gi+F%nbas(idof)-1

      ALLOCATE(T(F%nbas(idof)))

      bjk=0.d0

!     Loop over terms in H
      ik=1
      DO k=1,rH
!        Loop over terms in F
         DO i=1,rF
            call CPMatOrdVecProd(H(k,idof),F%base(gi:gf,i),T)
            T(:)=T(:)*F%coef(i)
!           Dot product <F,H*F>
            DO l=1,rF
               DO j=1,F%nbas(idof)
                  bjk(l,j)=bjk(l,j)+PS(ik,l)*T(j)
               ENDDO
            ENDDO
            ik=ik+1
         ENDDO
      ENDDO

!     Energy shift if applicable
      IF (ishift.ne.0) THEN
!        The usual case: (H-E*1)*v
         DO i=1,rF
            T(:)=Eshift*F%coef(i)*F%base(gi:gf,i)
            IF (idof.eq.1) T(:)=-T(:)
            DO l=1,rF
               DO j=1,F%nbas(idof)
                  bjk(l,j)=bjk(l,j)+PS(ik,l)*T(j)
               ENDDO
            ENDDO
            ik=ik+1
         ENDDO

!        The rare case: (E*1-H)*v
         IF (idof.eq.1) THEN
            IF (ishift.lt.0) THEN
               bjk=-bjk
            ENDIF
         ENDIF
      ENDIF

      DEALLOCATE(T)

      end subroutine PRODHV4bjk

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine ALS_ORTHOb(Q,nitn)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! ALS guided Gram-Schmidt orthogonalization. Given CP-format vectors
! stored in Q, the vectors are iteratively orthogonalized using ALS.
! This version updates the overlap coefficients after each ALS iteration

      implicit none
      TYPE (CPvec), INTENT(INOUT) :: Q(:)
      integer, intent(in)  :: nitn
      integer, allocatable :: nbas(:),ranks(:,:)
      real*8, allocatable  :: coefs(:),BB(:,:),PS(:,:),bjk(:,:),IPV(:,:)
      real*8  :: valpen,rnorm,gtmp,t1,t2
      integer :: iv,nbloc,rG,rF,rT,ndim,i,j,ir,imod,k,l,m,n,info,gst,itn
      integer :: nr

      IF (nitn.eq.0) return

!      call CPU_TIME(t1)

!     Set parameters
      nbloc=SIZE(Q)
      ndim=SIZE(Q(1)%nbas)

!     Store a pointer for the ranks of the vectors
      ALLOCATE(coefs(nbloc),ranks(nbloc,3))
      ranks(1,1)=1
      ranks(1,2)=SIZE(Q(1)%coef)
      ranks(1,3)=SIZE(Q(1)%coef)

!     Normalize the first vector
      call NORMCOEF(Q(1))

!     Loop over vectors in the block
      DO iv=2,nbloc

!        Penalty to avoid bad conditioning
         valpen=maxval(Q(iv)%coef)*1.d-10

!        Set ranks. rG is the sum of the ranks of the first iv vectors
         coefs(iv)=1.d0
         ranks(iv,1)=ranks(iv-1,2)+1
         ranks(iv,2)=ranks(iv-1,2)+SIZE(Q(iv)%coef)
         ranks(iv,3)=SIZE(Q(iv)%coef)
         rG=ranks(iv,2)
         rF=ranks(iv,3)

         ALLOCATE(PS(rG,rF))

!        PS(l,l') = Pi_{i=2}^ndim < G_i^l , F_i^l' >
!$omp parallel
!$omp do private(l)
         DO l=1,iv
            call CONSTPSTOT(Q(iv),Q(l),PS(ranks(l,1):ranks(l,2),1:rF))
         ENDDO
!$omp enddo
!$omp end parallel

!        Main loop over ALS iterations
         DO itn=1,nitn

!           Loop over dimension k
            gst=0
            DO k=1,ndim
               n=Q(iv)%nbas(k)

!              Compute the Gram-Schmidt expansion coefficients
               DO l=1,iv-1
                  coefs(l)=0.d0
                  rT=ranks(l,3)
                  DO i=1,rF
                     DO j=1,rT
                        coefs(l)=coefs(l)-PS(ranks(l,1)+j-1,i)*&
                                 Q(iv)%coef(i)*Q(l)%coef(j)
                     ENDDO
                  ENDDO
               ENDDO

!              Downdate PS (remove the k-th DOF)
!               DO l=1,iv
!                  rT=ranks(l,3)
!                  ALLOCATE(BB(rT,rF))
!                  call CONSTPSk(Q(iv),Q(l),k,BB)
!                  PS(ranks(l,1):ranks(l,2),1:rF)= &
!                  PS(ranks(l,1):ranks(l,2),1:rF)/ &
!                  BB(1:rT,1:rF)
!                  DEALLOCATE(BB)
!               ENDDO

               ALLOCATE(BB(rG,rF))
!$omp parallel
!$omp do private(l,rT)
               DO l=1,iv
                  rT=ranks(l,3)
                  call CONSTPSk(Q(iv),Q(l),k,&
                                BB(ranks(l,1):ranks(l,2),1:rF))
                  PS(ranks(l,1):ranks(l,2),1:rF)= &
                  PS(ranks(l,1):ranks(l,2),1:rF)/ &
                  BB(ranks(l,1):ranks(l,2),1:rF)
               ENDDO
!$omp enddo
!$omp end parallel
               DEALLOCATE(BB)


!              Copy the last rF x rF block of PS into BB and add penalty
!              to BB to avoid ill-conditioning (section 3.2, Beykin)
               ALLOCATE(BB(rF,rF))
               BB(1:rF,1:rF)=PS(ranks(iv,1):ranks(iv,2),1:rF)
               DO i=1,rF
                  BB(i,i)=BB(i,i)+valpen
               ENDDO

!              Calculate b_j_k ( l', nr) (Beylkin, eq. 3.4). This also
!              requires updating the Gram-Schmidt coefficients
               ALLOCATE(bjk(rF,n))

!               bjk=0.d0
!               DO ir=1,n
!                  imod=gst+ir
!                  DO l=1,iv
!                     rT=ranks(l,3)
!                     DO j=1,rT
!                        gtmp=coefs(l)*Q(l)%coef(j)*Q(l)%base(imod,j)
!                        DO i=1,rF
!                           bjk(i,ir)=bjk(i,ir)+gtmp*PS(ranks(l,1)+j-1,i)
!                        ENDDO
!                     ENDDO
!                  ENDDO
!               ENDDO

               nr=n*rF
!$omp parallel
!$omp do private(m,i,ir,imod,l,rT,j)
               DO m=1,nr
                  i=(m-1)/n+1
                  ir=mod(m-1,n)+1
                  imod=gst+ir
                  bjk(i,ir)=0.d0
                  DO l=1,iv
                     rT=ranks(l,3)
                     DO j=1,rT
                        bjk(i,ir)=bjk(i,ir)+coefs(l)*Q(l)%coef(j)*&
                           Q(l)%base(gst+ir,j)*PS(ranks(l,1)+j-1,i)
                     ENDDO
                  ENDDO              
               ENDDO
!$omp enddo
!$omp end parallel


!              Solve linear system B*c_j_k = b_j_k (eq 3.5)
!              (B includes all inner products except the kth)
!              Use DGETRF for LU factorization + DGETRS to solve system
               ALLOCATE(IPV(rF,rF))
               call dgetrf(rF,rF,BB,rF,IPV,info)
               call dgetrs('N',rF,n,BB,rF,IPV,bjk,rF,INFO)
               DEALLOCATE(BB,IPV)

!              Construct improved F
               DO i=1,rF
                  rnorm=sqrt(abs(dot_product(bjk(i,:),bjk(i,:))))
                  Q(iv)%coef(i)=rnorm
                  DO ir=1,n
                     imod=gst+ir
                     Q(iv)%base(imod,i)=bjk(i,ir)/rnorm
                  ENDDO
               ENDDO
               DEALLOCATE(bjk)

!              Check coefs of F for NaN values resulting from zero
!              division. If there are any, restart ALS without updating
               DO i=1,rF
                  IF (Q(iv)%coef(i).ne.Q(iv)%coef(i)) THEN
                     write(*,*) 'ALS_ORTHO(): NaN on update; itn = ',itn
                     call AbortWithError('ALS_ORTHO crashed')
                  ENDIF
               ENDDO

!              Update PS (calc inner products with new fs for k-th DOF)
!               DO l=iv,1,-1
!                  rT=ranks(l,3)
!                  ALLOCATE(BB(rT,rF))
!                  call CONSTPSk(Q(iv),Q(l),k,BB)
!                  PS(ranks(l,1):ranks(l,2),1:rF)= &
!                  PS(ranks(l,1):ranks(l,2),1:rF)* &
!                  BB(1:rT,1:rF)
!                  DEALLOCATE(BB)
!                 Only update BB (for normalization) on last pass
!                  IF (itn.eq.nitn .and. k.eq.ndim) EXIT
!               ENDDO

               ALLOCATE(BB(rG,rF))
!$omp parallel
!$omp do private(l,rT)
               DO l=1,iv
                  rT=ranks(l,3)
                  call CONSTPSk(Q(iv),Q(l),k,&
                                BB(ranks(l,1):ranks(l,2),1:rF))
                  PS(ranks(l,1):ranks(l,2),1:rF)= &
                  PS(ranks(l,1):ranks(l,2),1:rF)* &
                  BB(ranks(l,1):ranks(l,2),1:rF)
               ENDDO
!$omp enddo
!$omp end parallel
               DEALLOCATE(BB)


!              Normalization
               rnorm=0.d0
               DO i=1,rF
                  rnorm=rnorm+PS(ranks(iv,1)+i-1,i)*Q(iv)%coef(i)**2
                  DO j=1,i-1
                     rnorm=rnorm+2*PS(ranks(iv,1)+j-1,i)*&
                              Q(iv)%coef(i)*Q(iv)%coef(j)
                  ENDDO
               ENDDO
               rnorm=1/sqrt(abs(rnorm))
               Q(iv)%coef=rnorm*Q(iv)%coef

               gst=gst+n
            ENDDO  ! loop over k
         ENDDO  ! loop over iterations
         DEALLOCATE(PS)
      ENDDO  ! loop over vectors

      DEALLOCATE(ranks,coefs)

!      call CPU_TIME(t2)
!      alsham_time=alsham_time+t2-t1

      end subroutine ALS_ORTHOb

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine ALS_ORTHOa(Q,nitn)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! ALS guided Gram-Schmidt orthogonalization. Given CP-format vectors
! stored in Q, the vectors are iteratively orthogonalized using ALS.
! This version computes the overlap coefficients once per vector.

      implicit none
      TYPE (CPvec), INTENT(INOUT) :: Q(:)
      TYPE (CPvec) :: F
      integer, intent(in)  :: nitn
      integer, allocatable :: nbas(:),ranks(:,:)
      real*8, allocatable  :: coefs(:),bjk(:,:)
      real*8, allocatable  :: BBmem(:,:),PS(:,:),IPV(:,:),BB(:,:)
      real*8  :: valpen,rnorm,gtmp,t1,t2
      integer :: iv,nbloc,rG,rF,rT,ndim,i,j,ir,imod,k,l,n,info,gst,itn

      IF (nitn.eq.0) return

!      call CPU_TIME(t1)

!     Set parameters
      nbloc=SIZE(Q)
      ndim=SIZE(Q(1)%nbas)

!     Store a pointer for the ranks of the vectors
      ALLOCATE(coefs(nbloc),ranks(nbloc,3))
      ranks(1,1)=1
      ranks(1,2)=SIZE(Q(1)%coef)
      ranks(1,3)=SIZE(Q(1)%coef)

!     Normalize the first vector
      call NORMCOEF(Q(1))

!     Loop over vectors in the block
      DO iv=2,nbloc

!        Penalty to avoid bad conditioning
         valpen=maxval(Q(iv)%coef)*1.d-10

!        Set ranks. rG is the sum of the ranks of the first iv vectors
         coefs(iv)=1.d0
         ranks(iv,1)=ranks(iv-1,2)+1
         ranks(iv,2)=ranks(iv-1,2)+SIZE(Q(iv)%coef)
         ranks(iv,3)=SIZE(Q(iv)%coef)
         rG=ranks(iv,2)
         rF=ranks(iv,3)

         ALLOCATE(PS(rG,rF),BBmem(rF,rF))

         call CopyWtoV(F,Q(iv))

!        PS(l,l') = Pi_{i=2}^ndim < G_i^l , F_i^l' >
!$omp parallel
!$omp do private(l)
         DO l=1,iv
            call CONSTPSTOT(F,Q(l),PS(ranks(l,1):ranks(l,2),1:rF))
         ENDDO
!$omp enddo
!$omp end parallel

!        BB(l,l') = Pi_{i=2}^ndim < F_i^l , F_i^l' >
!        (on initialization, BB is also the last rF x rF block of PS)
         BBmem=PS(ranks(iv,1):ranks(iv,2),1:rF)

!        Compute the overlap coefficients for Gram-Schmidt
         DO l=1,iv-1
            coefs(l)=0.d0
            rT=ranks(l,3)
            DO i=1,rF
               DO j=1,rT
                  coefs(l)=coefs(l)-PS(ranks(l,1)+j-1,i)*&
                           Q(iv)%coef(i)*Q(l)%coef(j)
               ENDDO
            ENDDO            
         ENDDO

!        Loop over ALS iterations
         DO itn=1,nitn

!           Loop over dimension k
            gst=0
            DO k=1,ndim
               n=Q(iv)%nbas(k)

!              Downdate PS (remove the k-th DOF)
               DO l=1,iv
                  rT=ranks(l,3)
                  ALLOCATE(BB(rT,rF))
                  call CONSTPSk(F,Q(l),k,BB)
                  PS(ranks(l,1):ranks(l,2),1:rF)= &
                  PS(ranks(l,1):ranks(l,2),1:rF)/ &
                  BB(1:rT,1:rF)
                  DEALLOCATE(BB)
               ENDDO

!              Downdate BBmem and add penalty to avoid ill-conditioning
               ALLOCATE(BB(rF,rF))
               call CONSTBBk(F,k,BB)
               BBmem=BBmem/BB
               BB=BBmem
               DO i=1,rF
                  BB(i,i)=BB(i,i)+valpen
               ENDDO

!              Calculate b_j_k ( l', nr) (Beylkin, eq. 3.4).
               ALLOCATE(bjk(rF,n))
               bjk=0.d0
               DO ir=1,n
                  imod=gst+ir
                  DO l=1,iv
                     rT=ranks(l,3)
                     DO j=1,rT
                        gtmp=coefs(l)*Q(l)%coef(j)*Q(l)%base(imod,j)
                        DO i=1,rF
                           bjk(i,ir)=bjk(i,ir)+gtmp*PS(ranks(l,1)+j-1,i)
                        ENDDO
                     ENDDO
                  ENDDO
               ENDDO

!              Solve linear system B*c_j_k = b_j_k (eq 3.5)
!              (B includes all inner products except the kth)
!              Use DGETRF for LU factorization + DGETRS to solve system
               ALLOCATE(IPV(rF,rF))
               call dgetrf(rF,rF,BB,rF,IPV,info)
               call dgetrs('N',rF,n,BB,rF,IPV,bjk,rF,INFO)
               DEALLOCATE(BB,IPV)

!              Construct improved F
               DO i=1,rF
                  rnorm=sqrt(abs(dot_product(bjk(i,:),bjk(i,:))))
                  F%coef(i)=rnorm
                  DO ir=1,n
                     imod=gst+ir
                     F%base(imod,i)=bjk(i,ir)/rnorm
                  ENDDO
               ENDDO
               DEALLOCATE(bjk)

!              Check coefs of F for NaN resulting from zero division
               DO i=1,rF
                  IF (F%coef(i).ne.F%coef(i)) THEN
                     write(*,*) 'ALS_ORTHO(): NaN on update; itn = ',itn
                     call AbortWithError('ALS_ORTHO crashed')
                  ENDIF
               ENDDO

!              Update PS with the new Fs (skip on last pass)
               IF (itn.lt.nitn .or. k.lt.ndim) THEN
                  DO l=1,iv
                     rT=ranks(l,3)
                     ALLOCATE(BB(rT,rF))
                     call CONSTPSk(F,Q(l),k,BB)
                     PS(ranks(l,1):ranks(l,2),1:rF)= &
                     PS(ranks(l,1):ranks(l,2),1:rF)* &
                     BB(1:rT,1:rF)
                     DEALLOCATE(BB)
                  ENDDO
               ENDIF

!              Update BB (do even on last pass for normalization)
               ALLOCATE(BB(rF,rF))
               call CONSTBBk(F,k,BB)
               BBmem=BBmem*BB
               DEALLOCATE(BB)

               gst=gst+n
            ENDDO  ! loop over k
         ENDDO  ! loop over iterations

!        Normalize F and replace Q(iv) <- F
         rnorm=0.d0
         DO i=1,rF
            rnorm=rnorm+BBmem(i,i)*F%coef(i)**2
            DO j=1,i-1
               rnorm=rnorm+2*BBmem(i,j)*F%coef(i)*F%coef(j)
            ENDDO
         ENDDO
         rnorm=1/sqrt(abs(rnorm))
         F%coef=rnorm*F%coef
         call ReplaceVwithW(Q(iv),F)
         DEALLOCATE(PS,BBmem)
      ENDDO  ! loop over vectors

      DEALLOCATE(ranks,coefs)

!      call CPU_TIME(t2)
!      alsham_time=alsham_time+t2-t1

      end subroutine ALS_ORTHOa

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine PolyadGuess(il,im,Ham,ML,qns,eigv)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Guesses wavefunctions with quantum numbers summing to minimum values
!!! UNDER CONSTRUCTION

      implicit none
      TYPE (MLtree), INTENT(IN)      :: ML
      TYPE (Hamiltonian), INTENT(IN) :: Ham
      integer, intent(in)    :: il,im
      integer, allocatable :: qnt(:),qnfull(:,:),qntfull(:,:)
      integer, allocatable, intent(inout) :: qns(:,:)
      real*8, allocatable, intent(inout)  :: eigv(:)
      integer :: qn(1)
      integer :: i,j,nsubm,mstart,mst,mfi,nbloc,nbas,nagn,ll,ul
      real*8, allocatable :: sumqn(:),eigvt(:)
      real*8, allocatable :: tabindx(:),tabind2(:)
      character*64 :: frmt

!     Set parameters
      nsubm=ML%modcomb(il,im)   ! number of sub-modes in mode 'im'
      mstart=ML%modstart(il,im) ! start index of sub-modes of 'im'
      nbloc=ML%gdim(il,im)      ! block size (# eigfxns for 'im')
      nbas=ML%gdim(il-1,mstart) ! nubmer of basis functions in 'im'
      mst=firstmode(il,1,im,ML)
      mfi=lastmode(il,1,im,ML)
      nagn=mfi-mst+1

!     Exit unless this is a basis truncation node
      IF (nsubm.gt.1 .or. nbas.eq.nbloc) RETURN

      IF (ALLOCATED(qns)) DEALLOCATE(qns)
      IF (ALLOCATED(eigv)) DEALLOCATE(eigv)

      write(*,*) 'Polyad time!'
      write(*,*) 'nsubm,mstart,nbloc,nagn=',nsubm,mstart,nbloc,nagn

      write(frmt,*) '(A,X,',nagn,'(I2,X))'
      write(*,frmt) 'Mode:',(ML%resort(j),j=mst,mfi)

      ALLOCATE(qnfull(nbas,nagn))
      ALLOCATE(sumqn(nbas),eigv(nbas))

!     Copy the eigenvalues of the sub-modes to eigv
      eigv(1:nbas)=Ham%eig(il-1,mstart)%evals(:)

!     Loop over basis functions on previous layer
      DO i=1,nbas
         qn(1)=i
         call GetFoolAssignment(il,mstart,Ham,ML,qn,qnt)
         qnfull(i,:)=qnt(:)
         sumqn(i)=0.d0
         DO j=1,SIZE(qnt)
            sumqn(i)=sumqn(i)+qnt(j)-1.d0
         ENDDO
         DEALLOCATE(qnt)
      ENDDO

!     Print out list
      write(*,*) 'Here is the list of levels, unsorted:'
      write(frmt,'(A,I0,A)') '(I4,A,X,',nagn,'(I2,X),4X,I3,4X,f19.12)'
      DO i=1,nbas
         write(*,frmt) i,')',(qnfull(i,j)-1,j=1,nagn),INT(sumqn(i)),eigv(i)
      ENDDO
      write(*,*)

!     Sort the list by sumqn, copy to temp array
      ALLOCATE(tabindx(nbas),tabind2(nbas))
      DO i=1,nbas
         tabindx(i)=i
         tabind2(i)=i
      ENDDO
      call dsort(sumqn,tabindx,nbas,2)
      ALLOCATE(qntfull(nbas,nagn),eigvt(nbas))

!     Copy qnfull and eigv to temp array
      DO i=1,nbas
         qntfull(i,:)=qnfull(INT(tabindx(i)),:)
         eigvt(i)=eigv(INT(tabindx(i)))
      ENDDO

!     Sort each temp sumqn sub-list by energy
      ll=1
      ul=1
      DO
         DO
           IF (NINT(sumqn(ul)).gt.NINT(sumqn(ll))) THEN
              ul=ul-1
              EXIT
           ENDIF
           IF (ul.eq.nbas) EXIT
           ul=ul+1
         ENDDO
         call dsort(eigvt(ll:ul),tabind2(ll:ul),ul-ll+1,2)
         IF (ul.eq.nbas) EXIT
         ll=ul+1
         ul=ll
      ENDDO

      qnfull(:,:)=0
      eigv(:)=0.d0
!     Copy qntfull and eigvt back to original arrays
      DO i=1,nbas
         qnfull(i,:)=qntfull(INT(tabind2(i)),:)
      ENDDO

!     Print out list
      write(*,*) 'Here is the list of levels, sorted by sumqn and E:'
      write(frmt,'(A,I0,A)') '(I4,A,X,',nagn,&
                             '(I2,X),4X,I3,4X,f19.12,2X,I4)'
      DO i=1,nbas
         write(*,frmt) i,')',(qnfull(i,j)-1,j=1,nagn),INT(sumqn(i)),&
                       eigvt(i),NINT(tabindx(NINT(tabind2(i))))
      ENDDO
      write(*,*)

      DEALLOCATE(eigv)
      ALLOCATE(qns(nbloc,1),eigv(nbloc))
      DO i=1,nbloc
         qns(i,1)=NINT(tabindx(NINT(tabind2(i))))
         eigv(i)=eigvt(i)
      ENDDO

      DEALLOCATE(qntfull,eigvt)
      DEALLOCATE(qnfull,sumqn,tabindx,tabind2)

      end subroutine PolyadGuess

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine CPreciprocalA(F,G,nals)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Computes reciprocal of CP-vector F, and stores in G
! G is provided as an initial guess

      implicit none
      TYPE (CP), INTENT(IN)    :: F
      TYPE (CP), INTENT(INOUT) :: G
      TYPE (CP) :: I,Fdiag,G1
      real*8 :: fac
      integer, intent(in) :: nals
      integer :: itn,lowmem,j
!!! TEST      
      TYPE (CP) :: X,Y,Z,Y1,Z0,ZZ,Z1,Z2,Zp
!!!
      lowmem=1

      write(*,*)
      write(*,*) '*** CP reciprocalA(): ***'
      write(*,*)
!      write(*,*) 'G, the cheap inverse'
!      write(*,*)
!      call PrintCPvec(G)

      call NewCP(I,1,F%rows,F%cols,F%sym)
      I%base(:,:)=1.d0
      I%coef(:)=1.d0

      write(*,*)
      write(*,*) '||I|| = ',sqrt(abs(PRODVV(I)))
      call CPMM_vec(F,0,0.d0,G,0,0.d0,Z0)
      write(*,*) 'Itn: ',0,'; ||F*G-I|| = ',calc_FmG(Z0,I),&
                 '; ||F*G|| = ',sqrt(abs(PRODVV(Z0)))
      call FlushCP(Z0)

      DO j=1,5*nals

         call CPMM_vec(G,0,0.d0,F,0,0.d0,X)
         fac=sqrt(abs(PRODVV(X)))
         call SUMVECVEC(X,-1.d0,I,2.d0)
         call CPMM_vec(G,0,0.d0,X,0,0.d0,G1)
         call reduc_ALS(G1,G,nals)
         call FlushCP(X)
         call FlushCP(G1)

         call CPMM_vec(F,0,0.d0,G,0,0.d0,Z0)
         write(*,*) 'Itn: ',j,'; ||F*G-I|| = ',calc_FmG(Z0,I),&
                    '; ||F*G|| = ',sqrt(abs(PRODVV(Z0)))
         call FlushCP(Z0)
      ENDDO

      call CopyWtoV(X,I)
      call CopyWtoV(Y,I)
      call CopyWtoV(ZZ,I)
      call reduc_SR1(F,X,10*nals)
      call reduc_SR1(G,Y,10*nals)
      call CPMM_vec(X,0,0.d0,Y,0,0.d0,Z) ! Z = X*Y
      call NORMBASE(Z)
      call DistributeCoef(Z)
      call CopyWtoV(Y1,X)
      DO j=1,SIZE(Y1%base,1)
         Y1%base(j,1)=1.d0/Y1%base(j,1)
      ENDDO
      Y1%coef(1)=1.d0/Y1%coef(1)
      call NORMBASE(Y1)
      call CPMM_vec(F,0,0.d0,G,0,0.d0,Z0)  ! Z0 = F*G
!      call CPMM_vec(Zp,0,0.d0,G,0,0.d0,Z0)  ! Z0 = F*G**2
      call reduc_SR1(Z0,ZZ,10*nals)
      call CPMM_vec(X,0,0.d0,Y1,0,0.d0,Z1) ! Z1 = X*Y1
      call CPMM_vec(F,0,0.d0,Y1,0,0.d0,Z2) ! Z2 = F*Y1
      call NORMBASE(Z1)
      call DistributeCoef(Z1)
      call NORMBASE(Z2)
      call NORMBASE(ZZ)
      call DistributeCoef(ZZ)

!!!
!      write(*,*)
!      write(*,*) "Here is F"
!      write(*,*)
!      call PrintCPvec(F)
!      write(*,*)
!      write(*,*) "Here is I"
!      write(*,*)
!      call PrintCPvec(I)
!      write(*,*)
!      write(*,*) "Here is G"
!      write(*,*)
!      call PrintCPvec(G)
      write(*,*)
      write(*,*) "Here is X (rank-1 approx to F)"
      write(*,*)
      call PrintCPvec(X)
      write(*,*)
      write(*,*) "Here is Y (rank-1 approx to G)"
      write(*,*)
      call PrintCPvec(Y)
      write(*,*)
      write(*,*)
      write(*,*) "Here is Z (X_r1*Y_r1)"
      write(*,*)
      call PrintCPvec(Z)
      write(*,*)
!      write(*,*) "Here is Y1 (1/X)"
!      write(*,*)
!      call PrintCPvec(Y1)
!      write(*,*)
!      write(*,*) "Here is Z1 (X*Y1)"
!      write(*,*)
!      call PrintCPvec(Z1)
!      write(*,*)
      write(*,*) "Here is ZZ (F*G -> rank-1)"
      write(*,*)
      call PrintCPvec(ZZ)
      write(*,*)

      write(*,*) '||Z-I|| = ',calc_FmG(Z,I)
      write(*,*) '||Z1-I|| = ',calc_FmG(Z1,I)
      write(*,*) '||Z2-I|| = ',calc_FmG(Z2,I)
      write(*,*) '||Z0-I|| = ',calc_FmG(Z0,I)
      write(*,*) '||ZZ-I|| = ',calc_FmG(ZZ,I)

      call FlushCP(X)
      call FlushCP(Y)
      call FlushCP(Z)
!!!
      call FlushCP(I)

      call AbortWithError("Done")

      end subroutine CPreciprocalA

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine PRODHVa(F,G,H,ishift,Eshift)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Applies matrix-vector product H*F = G, where H is the Hamiltonian and
! F and G are vectors, all in CP-format. This version calls CPMM()

      implicit none
      TYPE (CP), INTENT(IN)  :: H
      TYPE (CP), INTENT(IN)  :: F
      TYPE (CP), INTENT(OUT) :: G
      integer, intent(in) :: ishift
      real*8, intent(in)  :: Eshift
      integer :: rF,rG,rH,rFH
      real*8  :: t1,t2

      IF (.NOT. MVP_SETUP) call InitializePRODHVModule()

      call CPU_TIME(t1)

!     Set parameters
      rF=SIZE(F%coef) ! rank of F
      rH=SIZE(H%coef) ! rank of H
      rFH=rF*rH
      rG=rFH
      IF (ishift.ne.0) rG=rG+rF

!     Early exit if H is applied to a zero vector
      IF (rF.eq.1 .and. F%coef(1).eq.0.d0) THEN
         G=CopyCP(F)
         RETURN
      ENDIF

      call CPMM(H,1,Eshift,.FALSE.,F,0,0.d0,.FALSE.,G)
!      call ResizeV(G,rG)

!     Energy shift if applicable
!      IF (ishift.ne.0) THEN
!         call GenCopyWtoV(G,F,rFH+1,rG,1,rF)
!         call VecScalarMult(G,Eshift,rFH+1,rG)
!         IF (ishift.gt.0) THEN  ! (H-E*1)*v
!            call VecSignChange(G,rFH+1,rG)
!         ELSE                   ! (E*1-H)*v
!            call VecSignChange(G,1,rFH)
!         ENDIF
!      ENDIF

      call CPU_TIME(t2)
      mvp_time=mvp_time+t2-t1

      end subroutine PRODHVa

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine PRODHV(F,G,H,ishift,Eshift)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Applies matrix-vector product H*F = G, where H is the Hamiltonian and
! F and G are vectors, all of which are in CP-format

      implicit none
      TYPE (CP), INTENT(IN)  :: H
      TYPE (CP), INTENT(IN)  :: F
      TYPE (CP), INTENT(OUT) :: G
      integer, intent(in) :: ishift
      real*8, intent(in)  :: Eshift
      integer :: i,j,k,ik,n,rF,rG,rH,rFH,ndof
      real*8  :: t1,t2

      IF (.NOT. MVP_SETUP) call InitializePRODHVModule()

      call CPU_TIME(t1)

!     Set parameters
      ndof=SIZE(F%nbas) ! # modes
      rF=SIZE(F%coef) ! rank of F
      rH=SIZE(H%coef) ! rank of H
      rFH=rF*rH
      rG=rFH
      IF (ishift.ne.0) rG=rG+rF

!     Early exit if H is applied to a zero vector
      IF (rF.eq.1 .and. F%coef(1).eq.0.d0) THEN
         G=CopyCP(F)
         RETURN
      ENDIF

      G=NewCP(rG,F%nbas)

!     Loop over DOFs in the mode
      DO j=1,ndof
         n=F%rows(j)
!        Loop over terms in H
         ik=1
         DO k=1,rH
!           Loop over terms in F
            DO i=1,rF
               IF (j.eq.1) G%coef(ik)=H%coef(k)*F%coef(i)
               call DGEMM('N','N',n,1,n,1.d0,&
               H%base(H%ibas(j):H%fbas(j),k),n,&
               F%base(F%ibas(j):F%fbas(j),i),n,0.d0,&
               G%base(G%ibas(j):G%fbas(j),ik),n)
               ik=ik+1
            ENDDO
         ENDDO
      ENDDO

!     Energy shift if applicable
      IF (ishift.ne.0) THEN
         call GenCopyWtoV(G,F,rFH+1,rG,1,rF)
         call VecScalarMult(G,Eshift,rFH+1,rG)
         IF (ishift.gt.0) THEN  ! (H-E*1)*v
            call VecSignChange(G,rFH+1,rG)
         ELSE                   ! (E*1-H)*v
            call VecSignChange(G,1,rFH)
         ENDIF
      ENDIF

      call CPU_TIME(t2)
      mvp_time=mvp_time+t2-t1

      end subroutine PRODHV

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine PRODHVR1(F,G,H,i,k)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Applies matrix-vector product H*F = G, where H is the Hamiltonian and
! F and G are vectors, for only ONE term of H and F. No E-shift is done.
! i and k correspond to terms of F and H to use, respectively.

      implicit none
      TYPE (CP), INTENT(IN)  :: H
      TYPE (CP), INTENT(IN)  :: F
      TYPE (CP), INTENT(OUT) :: G
      integer, intent(in) :: i,k
      integer :: j,rF,rH,ndof,n
      real*8  :: t1,t2

      IF (.NOT. MVP_SETUP) call InitializePRODHVModule()

      call CPU_TIME(t1)

!     Set parameters
      ndof=SIZE(F%nbas) ! # modes
      rF=SIZE(F%coef)   ! rank of F
      rH=SIZE(H%coef)   ! rank of H

!     Error checking
      IF (i.lt.1 .or. i.gt.rF) &
         call AbortWithError('PRODHVR1(): i is out of range')
      IF (k.lt.1 .or. k.gt.rH) &
         call AbortWithError('PRODHVR1(): k is out of range')

!     Early exit if H is applied to a zero vector
      IF (rF.eq.1 .and. F%coef(1).eq.0.d0) THEN
         G=CopyCP(F)
         RETURN
      ENDIF

      G=NewCP(1,F%nbas)
      G%coef(1)=H%coef(k)*F%coef(i)

!     Calculate matrix-vector product for each DOF
      DO j=1,ndof
         n=F%rows(j)         
         call DGEMM('N','N',n,1,n,1.d0,&
         H%base(H%ibas(j):H%fbas(j),k),n,&
         F%base(F%ibas(j):F%fbas(j),i),n,0.d0,&
         G%base(G%ibas(j):G%fbas(j),1),n)
      ENDDO

      call CPU_TIME(t2)
      mvp_time=mvp_time+t2-t1      

      end subroutine PRODHVR1

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine CPMM1(M1,ishift1,Eshift1,t1,M2,ishift2,Eshift2,t2,M3,idof)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Applies CP-format matrix-matrix product M1*M2 = M3, replacing values
! of M3 for mode k. Set tx (x={1,2}) to .TRUE. to do transpose.

      implicit none
      TYPE (CP), INTENT(IN)    :: M1,M2
      TYPE (CP), INTENT(INOUT) :: M3
      TYPE (CP) :: I1,I2
      integer, intent(in) :: idof
      integer :: ld1,ld2,r1,c1,r2,c2 
      integer :: i,k,ik,rk1,rk2,rk3,ndof
      real*8  :: alpha1,alpha2,afac,ti1,ti2
      real*8, intent(in)  :: Eshift1,Eshift2
      integer, intent(in) :: ishift1,ishift2
      logical, intent(in) :: t1,t2
      character(1) :: tN1,tN2            

      IF (.NOT. MVP_SETUP) call InitializePRODHVModule()

      call CPU_TIME(ti1)

!     Set parameters: # modes, ranks
      ndof=SIZE(M1%nbas)
      rk1=SIZE(M1%coef)
      rk2=SIZE(M2%coef)
      rk3=rk1*rk2

!     Alpha multiplies the matrix product and is always opposite in sign
!     to the energy shift
      alpha1=1.d0
      alpha2=1.d0
      
!     Modify ranks for shifts and generate shift terms
      IF (ishift1.ne.0) THEN
         rk3=rk3+rk2
         IF (ishift1.lt.0) alpha1=-alpha1
         I1=IdentityCPMatrix(M1%rows,M1%cols,M1%sym)
         call VecScalarMult(I1,-alpha1*Eshift1,1,1)
      ENDIF
      IF (ishift2.ne.0) THEN
         rk3=rk3+rk1
         IF (ishift2.lt.0) alpha2=-alpha2
         I2=IdentityCPMatrix(M2%rows,M2%cols,M2%sym)
         call VecScalarMult(I2,-alpha2*Eshift2,1,1)
      ENDIF
      IF (ishift1.ne.0 .and. ishift2.ne.0) rk3=rk3+1

!     Error checking
      IF (idof.lt.1 .or. idof.gt.ndof) THEN
         write(*,*) 'idof is ',idof,', but must be in range [1,',&
                    ndof,']'
         call AbortWithError('CPMM1(): mode index out of range')
      ENDIF
      IF (SIZE(M2%nbas).ne.ndof .or. SIZE(M3%nbas).ne.ndof) THEN
         write(*,*) 'M1, M2, M3 have ',ndof,', ',SIZE(M2%nbas),', ',&
                    SIZE(M3%nbas),' modes, respectively'
         call AbortWithError('CPMM1(): # modes in M1,M2,M3 must match')
      ENDIF
      IF (SIZE(M3%coef).lt.rk3) THEN
         write(*,*) 'M3 has rank ',SIZE(M3%coef),&
                    ', but must be at least ',rk3
         call AbortWithError('CPMM1(): rk_M3 too small for product')
      ENDIF
      IF (ANY(M1%sym) .or. ANY(M2%sym) .or. ANY(M3%sym)) &
         call AbortWithError('CPMM1(): symmetry not yet implemented')

!     Prepare DGEMM arguments 
      ld1=M1%rows(idof)
      ld2=M2%rows(idof)
      IF (t1) THEN
         tN1='T'
         r1=M1%cols(idof)
         c1=M1%rows(idof)
      ELSE
         tN1='N'
         r1=M1%rows(idof)
         c1=M1%cols(idof)
      ENDIF
      IF (t2) THEN
         tN2='T'
         r2=M2%cols(idof)
         c2=M2%rows(idof)
      ELSE
         tN2='N'
         r2=M2%rows(idof)
         c2=M2%cols(idof)
      ENDIF

      IF (c1.ne.r2) THEN
         write(*,*) 'Mode ',idof,': M1 cols (',c1,&
                    '), M2 rows (',r2,') must match'
         call AbortWithError('Error in CPMM1()')
      ENDIF
      IF (r1.ne.M3%rows(idof) .or. c2.ne.M3%cols(idof)) THEN
         write(*,*) 'Mode ',idof,': M3 must be (',r1,' x ',c2,&
         '), but is (',M3%rows(idof),' x ',M3%cols(idof),')'
         call AbortWithError('Error in CPMM1()')
      ENDIF

!     Loop over rank terms M1
      ik=1
      DO k=1,rk1
         IF (idof.eq.1) THEN
            afac=alpha1*alpha2
         ELSE
            afac=1.d0
         ENDIF
!        Loop over rank terms in M2
         DO i=1,rk2
!           Replace the coefficients since the calling subroutine
!           changes the coefficients after operating on each DOF
            M3%coef(ik)=M1%coef(k)*M2%coef(i)
            call DGEMM(tN1,tN2,r1,c2,c1,afac,&
                       M1%base(M1%ibas(idof):M1%fbas(idof),k),ld1,&
                       M2%base(M2%ibas(idof):M2%fbas(idof),i),ld2,0.d0,&
                       M3%base(M3%ibas(idof):M3%fbas(idof),ik),r1)
            ik=ik+1
         ENDDO

!        Shift on M2
         IF (ishift2.ne.0) THEN
            IF (idof.eq.1) THEN
               afac=alpha1
            ELSE
               afac=1.d0
            ENDIF
            M3%coef(ik)=M1%coef(k)*I2%coef(1)
            call DGEMM(tN1,tN2,r1,c2,c1,afac,&
                       M1%base(M1%ibas(idof):M1%fbas(idof),k),ld1,&
                       I2%base(I2%ibas(idof):I2%fbas(idof),1),ld2,0.d0,&
                       M3%base(M3%ibas(idof):M3%fbas(idof),ik),r1)

            ik=ik+1
         ENDIF
      ENDDO

!     Shift on M1
      IF (ishift1.ne.0) THEN
         IF (idof.eq.1) THEN
            afac=alpha2
         ELSE
            afac=1.d0
         ENDIF
         DO i=1,rk2
            M3%coef(ik)=I1%coef(1)*M2%coef(i)
            call DGEMM(tN1,tN2,r1,c2,c1,afac,&
                       I1%base(I1%ibas(idof):I1%fbas(idof),1),ld1,&
                       M2%base(M2%ibas(idof):M2%fbas(idof),i),ld2,0.d0,&
                       M3%base(M3%ibas(idof):M3%fbas(idof),ik),r1)
            ik=ik+1
         ENDDO
      ENDIF

!     Shift on both M1 and M2
      IF (ishift1.ne.0 .and. ishift2.ne.0) THEN
         M3%coef(ik)=I1%coef(1)*I2%coef(1)
         call DGEMM(tN1,tN2,r1,c2,c1,1.d0,&
                    I1%base(I1%ibas(idof):I1%fbas(idof),1),ld1,&
                    I2%base(I2%ibas(idof):I2%fbas(idof),1),ld2,0.d0,&
                    M3%base(M3%ibas(idof):M3%fbas(idof),ik),r1)
      ENDIF

      call CPU_TIME(ti2)
      mvp_time=mvp_time+ti2-ti1

      end subroutine CPMM1

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine LinfinityNorm0(F,nals,norm)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Use intertwining to compute largest element of F

      implicit none
      TYPE (ALS) :: X
      TYPE (CP), intent(in) :: F
      TYPE (CP) :: Ft,G
      integer, allocatable :: rown(:),coln(:)
      real*8, intent(out) :: norm
      integer, intent(in) :: nals
      integer :: i,d,ndof
      logical :: conv
      real*8 :: val

      ndof=SIZE(F%nbas)

!     Calc Ft*Ft = G, then create the ALS object
      Ft=CopyCP(F)
      call NORMALIZE(Ft)
      call CPMM_vec(Ft,Ft,G)
!!!
!      write(*,*) 'Ft'
!      call PrintCPmat(Ft)
!      write(*,*) 'G'
!      call PrintCPmat(G)
!!!
      call NewALS(X,Ft,G)
      call X%show

      DO i=1,nals
         DO d=1,ndof
            write(*,*) 'itn,d =',i,d
            call ProdMatsDD(X,Ft,G,d)
            call SolveLS(X,Ft,G,d)
            IF (d.eq.ndof) call NORMCOEF(Ft)
            call CPMM_vec(F,0,0.d0,Ft,0,0.d0,G,d)
!!!
      write(*,*) 'Ft, itn,d =',i,d
      call PrintCPvec(Ft)
!      write(*,*) 'G, itn,d =',i,d
!      call PrintCPmat(G)
!!!

            call ProdMatsUD(X,Ft,G,d,conv)
         ENDDO
      ENDDO

      call FlushCP(G)
      call X%Flush

!     Reduce Ft to a normalized rank-1 CP (as G)
      G=RandomCP(1,F%rows,F%cols,F%sym)
      call ALS_reduce(G,Ft,nals)
      G%coef(1)=1.d0  ! normalize coef of G

      write(*,*) 'Converged l-inf matrix:'
      call PrintCPmat(G)

!     Extract the dominant index. val -> +1 or -1 if converged
      call GetRank1DominantEntry(G,rown,coln,val)
      call FlushCP(G)

!     Get the value of the tensor at the dominant index
      norm=ExtractCPmatrixElement(F,rown,coln)

      write(*,*) 'Row [',(rown(d),d=1,ndof),']'
      write(*,*) 'Col [',(coln(d),d=1,ndof),']'
      write(*,*) 'Converg = ',val
      write(*,*) 'L_infty = ',norm

      call FlushCP(Ft)
      call X%Flush

      deallocate(rown,coln)

      call AbortWithError('done infinitizing')

      end subroutine LinfinityNorm0

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine reduc_QRM(G,F,nitn)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Receives G (represented in reduced form) and F (trial vector to be
! reduced), and approximates G by F via QR-decomp of the RHS
! The subroutine optimizes F in dimensions k=1,ndim in succession.
 
      implicit none
      TYPE (CP), INTENT(IN) :: G
      TYPE (CP), INTENT(INOUT) :: F
      integer, intent(in)  :: nitn
      real*8, dimension (:,:), allocatable :: BB,PS,bjk,BBmem,rhs,U,VT
      real*8, allocatable :: svals(:)
      real*8  :: valpen,gtmp
      integer :: rG,rF,ndim,i,j,ir,ic,imod,k,l,n,gst,itn,kp,rz,cz
      logical :: update

      TYPE (CP) :: v

      IF (nitn.eq.0) return

!     Set parameters
      rG=SIZE(G%coef)
      rF=SIZE(F%coef)
      ndim=SIZE(G%nbas)

!     Update the ALS matrices BB and PS if ndim > 3. For ndim <= 3 it
!     is faster to build BB and PS at each iteration.
!     Building also avoids possible zero division during the update.
      update=.TRUE.
      IF (ndim.le.3)  update=.FALSE.

      allocate(BB(rF,rF),BBmem(rF,rF),PS(rG,rF))

!     Penalty to avoid bad conditioning
      valpen=maxval(G%coef)*1.d-15

76    continue

!     BB(l,l') = Pi_{i=2}^ndim < F_i^l , F_i^l' >
!     PS(l,l') = Pi_{i=2}^ndim < G_i^l , F_i^l' >
!     If the ALS matrices BB and PS are to be updated, initialize
!     them here with the first DOF removed

      IF (update) THEN
         call CONSTPT(F,1,BBmem)
         call CONSTPT(F,G,1,PS)
      ENDIF

!     Main loop over ALS iterations
      kp=0
      DO itn=1,nitn

!        Loop over dimension k
         gst=0
         do k=1,ndim
            n=F%nbas(k)

!           Update the BB and PS matrices of the linear system. This
!           also requires copying BBmem <-- BB since LAPACK destroys BB
            IF (update) THEN
               IF (kp.ne.0) then
                  call UPDATEP(F,k,BBmem,.TRUE.)
                  call UPDATEP(F,G,k,PS,.TRUE.)
               ENDIF
               BB=BBmem

!           Alternatively, build BB and PS from scratch
            ELSE 
               call CONSTPT(F,k,BB)
               call CONSTPT(F,G,k,PS)
            ENDIF

!           Add penalty to avoid ill-conditioning (section 3.2, Beylkin)
            do i=1,rF
               BB(i,i)=BB(i,i)+valpen
            enddo

!           Calculate b_j_k ( l', nr) (Beylkin, eq. 3.4)
            allocate(bjk(rF,n))
            bjk=0.d0
            do ir=1,n
               imod=gst+ir
               do j=1,rG
                  gtmp=G%coef(j)*G%base(imod,j)
                  do i=1,rF
                     bjk(i,ir)=bjk(i,ir)+gtmp*PS(j,i)
                  enddo
               enddo
            enddo

!           Solve linear system B*c_j_k = b_j_k (eq 3.5)
!           (B includes all inner products except the kth)
!            call SolveLinSysLU(BB,bjk)
!            call SolveLinSysSVD(BB,bjk)

!           Reshape the rhs from above and do QR decomp
            rz=F%rows(k)
            cz=F%cols(k)
            allocate(rhs(rz*rF,cz))
            do i=1,rF
               do ir=1,rz
                  do ic=0,cz-1
                     rhs((ir-1)*rF+i,ic+1)=bjk(i,ic*rz+ir)
                  enddo
               enddo
            enddo
            deallocate(bjk)

!           Solve with QR decomp...
            call QRdecomp(bjk,rhs)
!           Or with SVD
!            call SolveWithSVD(svals,rhs,U,VT)
!            deallocate(rhs)
!            call MatrixMult(U,.FALSE.,VT,.FALSE.,bjk)
!            deallocate(U,VT,svals)

!           Construct improved F
            call UpdateFfromSoln(F,bjk,k)
            deallocate(bjk)
            deallocate(rhs)

!           Check coefs of F for NaN values resulting from zero
!           division. If there are any, restart ALS without updating
            IF (.NOT. CHECKCOEFS(F)) THEN
               write(*,*) 'reduc_ALS(): NaN on update; itn = ',itn,&
                          ', mode = ',k
               call FlushCP(F)
               F=RandomCP(rF,G%rows,G%cols,G%sym)
               update=.FALSE.
               GOTO 76
            ENDIF

!           Update BB and PS with new Fs
            IF (update) THEN
               IF (itn.lt.nitn .or. k.lt.ndim) THEN
                  call UPDATEP(F,k,BBmem,.FALSE.)
                  call UPDATEP(F,G,k,PS,.FALSE.)
               ENDIF
            ENDIF

            gst=gst+n
            kp=k
         enddo  ! loop over k
      ENDDO  ! loop over iterations

!     Compute the final coefficients of F. Most of the work required to
!     compute these is already in PS, so one only needs to multiply PS
!     by PSk for k = ndim and then scale by the coefs of G to get <F,G>
!      call UPDATEP(F,G,ndim,PS,.FALSE.)

!      ALLOCATE(svals(rG))
!      svals(:)=G%coef(:)
!      call MatVecProd(PS,.TRUE.,svals)
!      F%coef(:)=svals(:)

      deallocate(BB,BBmem,PS)

      end subroutine reduc_QRM

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine TestreducQRM(H,U,Eshift)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      implicit none
      TYPE (CP), intent(in)    :: H
      TYPE (CP), intent(in) :: U
      TYPE (CP) :: Q,Q1,W
      integer, parameter :: nals=10
      integer, parameter :: nitn=1
      real*8, intent(in) :: Eshift
      integer :: i

      Q=CopyCP(U)

      DO i=1,nitn
!        Matrix-matrix product: W <-- (H-E1)*U; reduce rank U <-- W
         call CPMM(H,1,Eshift,.FALSE.,Q,0,0.d0,.FALSE.,W)
         call reduc_ALS(W,Q,nals)
         call CPMatNormA(Q,nals)
         call ShowNorm(Q)
!         call OrthogCPmatA(Q,nals)
!         call OrthogCPmatB(Q,nals)
         call OrthogCPmatRX(Q,4)
         call ShowNorm(Q)
!        Check the QR decomp      
         write(*,*) 'Here is QTQ, reduced to rank-1'
         call ShowRank1UTU(Q)
         write(*,*) 'Here is R, reduced to rank-1'
         call ShowRank1R(W,Q)
         call FlushCP(W)
         call ShowRQ(H,Q)
      ENDDO

!      call ShowRQ(H,Q)

      call FlushCP(Q)

      end subroutine TestreducQRM

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      function ALS_Schulz(A,nitn,nals) result (U)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Driver for intertwined Schulz iteration for inverting matrices

      implicit none
      TYPE (ALS) :: Xuc,Xvb
      TYPE (CP), intent(in) :: A
      TYPE (CP) :: U,V,B,C
      integer, intent(in) :: nitn,nals
      integer :: i,d,ndof
      logical :: conv
      real*8  :: fac,sb,sv,diff

      ndof=SIZE(A%nbas)

!     Initializations:
      U=CopyCP(A)
      call CPMatrixTranspose(U)
      call CPMM(U,.FALSE.,U,.TRUE.,V)
      fac=PRODVV(V)
      fac=1.d0/sqrt(abs(fac))
      call VecScalarMult(U,fac,1,SIZE(U%coef))
      call AugmentVWithRandomN(U,3) !!! larger rank succeeds better!
      call FlushCP(V)

!!!
      write(*,*) 'i,d, U dfI = ',0,0,SDfI(U)
!!!
      call CPMM(U,.FALSE.,A,.FALSE.,B) ! U_k*A
      write(*,*) 'ALS:'
      V=CopyCP(U)
      call ALS_reduce(V,B,nals)        ! V <- U_k*A
      write(*,*) 'ALS done'
      call CPMM(V,-1,2.d0,.FALSE.,U,0,0.d0,.FALSE.,C) ! C <- (2*I-V)*U_k

!     ALS objects for the two reduction steps
      call NewALS(Xuc,U,C)
      call NewALS(Xvb,V,B)

!!!
      sb=SDfI(B)
      sv=SDfI(V)
      diff=abs(sb-sv)
      write(*,*) 'i,d, B dfI = ',0,0,sb,&
      '; V dfI =',sv,'; diff = ',diff
!!!

!     Intertwining iterations
      do i=1,nitn
         do d=1,ndof
            write(*,*) 'itn,d = ',i,d

!           Update U, mode d
            call ProdMatsDD(Xuc,U,C,d)
            call SolveLS(Xuc,U,C,d)

!           Calculate B using new U, mode d
            call ProdMatsDD(Xvb,V,B,d)
            call CPMM(U,0,0.d0,.FALSE.,A,0,0.d0,.FALSE.,B,d)
!!! Copy V <- U here ?
            
            call SolveLS(Xvb,V,B,d)
            call ProdMatsUD(Xvb,V,B,d,conv)

!           Calculate C using new V, mode d
            call CPMM(V,-1,2.d0,.FALSE.,U,0,0.d0,.FALSE.,C,d)
            call ProdMatsUD(Xuc,U,C,d,conv)
!!! Update V from whats in U here?
!!!
            sb=SDfI(B)
            sv=SDfI(V)
            diff=abs(sb-sv)
            write(*,*) 'i,d, B dfI = ',i,d,sb,&
            '; V dfI =',sv,'; diff = ',diff
!!!
         enddo
      enddo

      call Xuc%Flush
      call Xvb%Flush
      call FlushCP(C)
      call FlushCP(B)
      call FlushCP(V)

      end function ALS_Schulz

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      function ALS_SchulzX(A,nitn,nals) result (U)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Driver for non-intertwined Schulz iteration for inverting matrix

      implicit none
      TYPE (CP), intent(in) :: A
      TYPE (CP) :: U,V,B,C
      integer, intent(in) :: nitn,nals
      integer :: i,d,ndof,rk
      logical :: conv
      real*8  :: fac

      ndof=SIZE(A%nbas)
      rk=6

!     Initializations:
      U=CopyCP(A)
      call CPMatrixTranspose(U)
      call CPMM(U,.FALSE.,U,.TRUE.,V)
      fac=PRODVV(V)
      fac=1.d0/sqrt(abs(fac))
      call VecScalarMult(U,fac,1,SIZE(U%coef))
      call AugmentVWithRandomN(U,rk) !!! larger rank succeeds better!
      call FlushCP(V)

      write(*,*) 'i, U dfI = ',0,SDfI(U)

!     Intertwining iterations
      do i=1,nitn
         write(*,*) 'itn = ',i

!        Calculate B using new U
         call CPMM(U,.FALSE.,A,.FALSE.,B) ! U_k*A
!         V=CopyCP(U)
         V=IdentityCPMatrix(U%rows,U%cols,U%sym)
         call AugmentVWithRandomN(V,rk)
         call ALS_reduce(V,B,nals)        ! V <- U_k*A

!        Calculate C using new V
         call CPMM(V,-1,2.d0,.FALSE.,U,0,0.d0,.FALSE.,C)
         call ALS_reduce(U,C,nals)

         write(*,*) 'i, B dfI = ',i,SDfI(B),'; V dfI =',SDfI(V)
         call FlushCP(V)
      enddo

      call FlushCP(C)
      call FlushCP(B)
      call FlushCP(V)

      end function ALS_SchulzX

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      function ALS_SchulzY(A,nitn,nals) result (U)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Driver for non-intertwined Schulz iteration for inverting matrix
! This version has no intermediate rank-reduction

      implicit none
      TYPE (CP), intent(in) :: A
      TYPE (CP) :: U,B,C
      integer, intent(in) :: nitn,nals
      integer :: i
      real*8  :: fac

!     Initializations:
      U=CopyCP(A)
      call CPMatrixTranspose(U)
      call CPMM(U,.FALSE.,U,.TRUE.,B)
      fac=PRODVV(B)
      fac=1.d0/sqrt(abs(fac))
      call VecScalarMult(U,fac,1,SIZE(U%coef))
      call AugmentVWithRandomN(U,3) !!! larger rank succeeds better!
      call FlushCP(B)

      write(*,*) 'i, U dfI = ',0,SDfI(U)

!     Intertwining iterations
      do i=1,nitn
         write(*,*) 'itn = ',i

!        Calculate B using new U
         call CPMM(U,.FALSE.,A,.FALSE.,B) ! U_k*A
!        Calculate C using B
         call CPMM(B,-1,2.d0,.FALSE.,U,0,0.d0,.FALSE.,C)
         call ALS_reduce(U,C,nals)

         write(*,*) 'i, B dfI = ',i,SDfI(B)
      enddo

      call FlushCP(C)
      call FlushCP(B)

      end function ALS_SchulzY

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      function SDfI(U) result (ans)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Computes distance from identity matrix

      implicit none
      TYPE (CP), INTENT(IN) :: U
      TYPE (CP) :: I,X
      real*8 :: imag,ans
      character(len=64) :: frmt

      frmt='(A,ES14.8)'

      I=IdentityCPMatrix(U%rows,U%cols,U%sym)
      imag=sqrt(abs(PRODVV(I)))
      ans=calc_FmG(U,I)/imag
!      write(*,frmt) 'Distance from Identity: ||U_R - I||/||I|| = ',ans
      call FlushCP(I)

      end function SDfI

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine HGintertwine(H,U,npow,nals,ishift,Eshift)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Driver for ALS power method ("intertwining")

      implicit none
      TYPE (CP), intent(in) :: H
      TYPE (CP), intent(inout) :: U
      TYPE (CP) :: W,V,Y,S,S2,P1,P2,Pr,Z
      TYPE (ALS) :: Xuw,Xyv,Xsy,Xus,Xpp,Xup
      integer, intent(in) :: npow,nals,ishift
      real*8, intent(in) :: Eshift
      integer :: i,j,d,ndof,rk,rkp2e
      logical, allocatable :: domode(:)
      logical :: conv
!!!
      TYPE (CP) :: T
!!!

      ndof=U%D()
      rk=U%R()
      rkp2e=U%R()**2

      write(*,*)
      write(*,*) '*** HGintertwine(), Eshift = ',Eshift,' ***'
      write(*,*)

      write(*,*) 'Rayleigh Quotients, itn = ',0
      call ShowRQ(H,U)

!     INITIALIZATIONS (lots and lots of them!):

      allocate(domode(ndof))
      domode(:)=.TRUE.
      domode(1)=.FALSE.

      write(*,*) 'Initial U: '
      write(*,*)
      call U%print()
      write(*,*) 'Initial UTU (rank-1)'
      call ShowRank1UTU(U)

!     Calc (H-E*I)*U = W and create the matrix-multiplication ALS object
      write(*,*) 'Initial MMP: (H-E*I)*U = W, and init Xuw'
      write(*,*)
      call CPMM(H,ishift,Eshift,.FALSE.,U,0,0.d0,.FALSE.,W)
      call NewALS(Xuw,U,W)
      write(*,*) 'Starter W: '
      write(*,*)
      call W%print()

!     Self-inner product: full-rank (V) with 0'd off-diag elements
      write(*,*) 'U^T*U = V inner product matrix'
      write(*,*)
      call CPMM(U,.TRUE.,U,.FALSE.,V)
      write(*,*) 'Self-product matrix V (not zeroed): '
      write(*,*)
      call V%print()
      call CPMatrixZeroOffDiag(V)
      write(*,*) 'Zero off-diag of V:'
      write(*,*)
      call V%print()

!     Self-inner product: reduced-rank (Y), with 0'd off-diag elements
      write(*,*) 'Init Y, the to-be-reduced-rank vsn of V'
      write(*,*)
      Y=RandomCP(rk,V%rows,V%cols,V%sym)
      write(*,*) 'Zero off-diag of Y (before optimizing to equal V)'
      write(*,*)
      call CPMatrixZeroOffDiag(Y)
      call Y%print()

!     Y <-ALS- V rank-reduction, and associated object
      write(*,*) 'Reduce Y <-ALS- V'
      write(*,*)
      call ALS_reduce(Xyv,Y,V,nals)
      write(*,*) 'Y, the reduced-rank inner product matrix: '
      write(*,*)
      call Y%print()

!     S = sqrt(Y) and associated solver object
      write(*,*) 'Guess S, the square root of Y, and init Xsy'
      write(*,*)
      call ReciprocalGuessM(Y,S,rk,nals)
      write(*,*) 'Iterate S to convergence via CPsqrtD()'
      write(*,*)
      call CPsqrtD(Y,S,npow,nals)
      write(*,*) 'S, the sqrt(Y) matrix: '
      write(*,*)
      call S%print()
      write(*,*) 'S * S = S^2, and init Xsy'
      write(*,*)
      call CPMM(S,.FALSE.,S,.FALSE.,S2)
      call NewLinSolver(Xsy,S,S,Y,.TRUE.,.TRUE.)
      write(*,*) 'S^2 (for the S * S = Y solver: '
      write(*,*)
      call S2%print()


      write(*,*) 'S * U = Z, and init Xus'
      write(*,*)
      call CPMatrixTranspose(U)
      call CPMM(S,.FALSE.,U,.FALSE.,Z)
      call NewLinSolver(Xus,S,U,U,.TRUE.,.TRUE.)
      write(*,*) 'Z (for the S * Un^T = U^T solver): '
      write(*,*)
      call CPMatrixTranspose(U)
      call U%show()

!     Initialize orthogonalization matrices and objects:
!     P1 = U1^T*U; Pr <-ALS- P1; P2 = -U1*Pr + U; U <-ALS- P2
      P1=CopyCP(V)
      Pr=RandomCP(rk,P1%rows,P1%cols,P1%sym)
      call ALS_reduce(Xpp,Pr,P1,nals)
      call CPMM(U,.FALSE.,Pr,.FALSE.,P2)
      call SUMVECVEC(P2,-1.d0,U,1.d0)
      call NewALS(Xup,U,P2)

      write(*,*) 'P1 (1st projecter step): '
      write(*,*)
      call P1%print()
      write(*,*) 'Pr (1st projecter step reduction): '
      write(*,*)
      call Pr%print()
      write(*,*) 'P2 (2nd projecter step): '
      write(*,*)
      call P2%print()

!!! END 1-col-at-a-time items
      write(*,*)
      write(*,*) 'Done initializing'
      write(*,*)
      write(*,*) 'MAIN LOOP'
      write(*,*)

!      call AbortWithError('done')


!      call Xuw%setoption('chkconv',.FALSE.)
!      call Xyv%setoption('chkconv',.FALSE.)
!      call Xsy%setoption('chkconv',.FALSE.)
!      call Xus%setoption('chkconv',.FALSE.)
!      call Xpp%setoption('chkconv',.FALSE.)
!      call Xup%setoption('chkconv',.FALSE.)
      call Xuw%setname('Xuw')
      call Xyv%setname('Xyv')
      call Xsy%setname('Xsy')
      call Xus%setname('Xus')
      call Xpp%setname('Xpp')
      call Xup%setname('Xup')

      DO i=1,npow
         DO d=1,ndof
         write(*,*) 'i,d = ',i,d,': ALS object downdates:'

!           Downdate all the ALS objects
            call ProdMatsDD(Xuw,U,W,d)
            call ProdMatsDD(Xyv,Y,V,d)
            call ProdMatsDD(Xsy,S2,Y,d)
            call CPMatrixTranspose(U)
            call ProdMatsDD(Xus,Z,U,d)
            call CPMatrixTranspose(U)
            call ProdMatsDD(Xpp,Pr,P1,d)
            call ProdMatsDD(Xup,U,P2,d)

!           Reduction U <- W for mode d
            call SolveLS(Xuw,U,W,d)

            write(*,*)
            write(*,*) 'i,d = ',i,d,'; V b4 orthog:'
            call V%print()
            write(*,*)
            write(*,*) 'i,d = ',i,d,'; Y b4 orthog:'
            call Y%print()
            write(*,*)
            write(*,*) 'i,d = ',i,d,'; S b4 orthog:'
            call S%print()
            write(*,*)
            write(*,*) 'i,d = ',i,d,'; S2 b4 orthog:'
            call S2%print()
            write(*,*)
            write(*,*) 'i,d = ',i,d,'; P1 b4 orthog:'
            call P1%print()
            write(*,*)
            write(*,*) 'i,d = ',i,d,'; Pr b4 orthog:'
            call Pr%print()
            write(*,*)
            write(*,*) 'i,d = ',i,d,'; P2 b4 orthog:'
            call P2%print()


!           Orthogonalize vectors along mode d
            call HGOrthoNorm1(Xyv,Xsy,Xus,Xpp,Xup,&
                              U,V,Y,S,S2,P1,P2,Pr,nals,d)

            write(*,*) 'i,d = ',i,d,': CP updates:'

!           Update normalization matrices/objects with the new N-col U
            call CPMM(U,0,0.d0,.TRUE.,U,0,0.d0,.FALSE.,V,d) ! regen V
            call CPMatrixZeroOffDiag(V,d)
            call SolveLS(Xyv,Y,V,d) ! regen Y
            call CPMM(S,0,0.d0,.FALSE.,S,0,0.d0,.FALSE.,S2,d) ! regen S2
            call CPsqrt1(Xsy,Y,S,S2,nals,d) ! Regen S and S2
            call CPMM(U,0,0.d0,.TRUE.,U,0,0.d0,.FALSE.,P1,d) ! regen P1
            call SolveLS(Xpp,Pr,P1,d) ! regen Pr
            call CPMM(U,0,0.d0,.FALSE.,Pr,0,0.d0,.FALSE.,P2,d) ! regen P2
            IF (d.eq.1) call VecSignChange(P2,1,rkp2e)
            P2%coef(rkp2e+1:P2%R())=U%coef(:)
            P2%base(P2%ibas(d):P2%fbas(d),rkp2e+1:P2%R())=&
            U%base(U%ibas(d):U%fbas(d),:)

            write(*,*) 'i,d = ',i,d,': power iteration:'

!           Update power iteration matrix-matrix product
            call CPMM(H,ishift,Eshift,.FALSE.,U,0,0.d0,.FALSE.,W,d)

            write(*,*) 'i,d = ',i,d,': ALS object updates:'

!           Update all the ALS objects (and Z, which requires U^T)
            call ProdMatsUD(Xuw,U,W,d,conv)
            call ProdMatsUD(Xyv,Y,V,d,conv)
            call ProdMatsUD(Xsy,S2,Y,d,conv)
            call CPMatrixTranspose(U)
            call CPMM(S,0,0.d0,.FALSE.,U,0,0.d0,.FALSE.,Z,d)
            call ProdMatsUD(Xus,Z,U,d,conv)
            call CPMatrixTranspose(U)
            call ProdMatsUD(Xpp,Pr,P1,d,conv)
            call ProdMatsUD(Xup,U,P2,d,conv)

            write(*,*)
            write(*,*) 'U after i,d = ',i,',',d,':'
            call U%print()
            write(*,*)
            write(*,*) 'i,d = ',i,d,'; V after orthog:'
            call V%print()
            write(*,*)
            write(*,*) 'i,d = ',i,d,'; Y after orthog:'
            call Y%print()
            write(*,*)
            write(*,*) 'i,d = ',i,d,'; S after orthog:'
            call S%print()
            write(*,*)
            write(*,*) 'i,d = ',i,d,'; S2 after orthog:'
            call S2%print()
            write(*,*)
            write(*,*) 'i,d = ',i,d,'; P1 after orthog:'
            call P1%print()
!            write(*,*)
!            write(*,*) 'i,d = ',i,d,'; P1, rank-1 after orthog:'
!            T=RandomCP(1,P1%rows,P1%cols,P1%sym)
!            call reduc_SR1(P1,T,100)
!            call T%print
!            call FlushCP(T)
            write(*,*)
            write(*,*) 'i,d = ',i,d,'; Pr after orthog:'
            call Pr%print()
            write(*,*)
            write(*,*) 'i,d = ',i,d,'; P2 after orthog:'
            call P2%print()

            write(*,*)
            write(*,*) 'UTU (rank-1) after i,d = ',i,',',d,':'
            call ShowRank1UTU(U)

!            call AbortWithError('done with first mode')
         ENDDO
!        Clear diagonal entries for all-but-first mode in P1
!        Rebuild ALS objects with diagonal-cleared P1
         call CPMatrixZeroOffDiag(P1,domode)
         call Xpp%Flush
         call NewALS(Xpp,Pr,P1)
!         call Xpp%setoption('chkconv',.FALSE.)
         call Xpp%setname('Xpp')
         write(*,*) 'Rayleigh Quotients, itn = ',i
         call ShowRQ(H,U)

!         call AbortWithError('done with one sweep')
      ENDDO

      deallocate(domode)
      call FlushCP(W)
      call FlushCP(V)
      call FlushCP(Y)
      call FlushCP(S)
      call FlushCP(S2)
      call FlushCP(P1)
      call FlushCP(P2)
      call FlushCP(Pr)
      call FlushCP(Z)
      call Xuw%Flush
      call Xyv%Flush
      call Xsy%Flush
      call Xus%Flush
      call Xpp%Flush
      call Xup%Flush

      call AbortWithError('done HGintertwining')

      end subroutine HGintertwine

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine HGOrthoNorm1(Xyv,Xsy,Xus,Xpp,Xup,&
                              U,V,Y,S,S2,P1,P2,Pr,nals,d)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Solves the single-mode orthonormalization problem for the intertwined
! HG iteration, for mode d

      implicit none
      TYPE (ALS), INTENT(INOUT) :: Xyv,Xsy,Xus,Xpp,Xup
      TYPE (CP), INTENT(INOUT)  :: U,V,Y,S,S2,P1,P2,Pr
      TYPE (CP) :: U1,UN,V1,Y1,S1,S21,P11,Pr1
      integer, intent(in) :: nals,d
      integer, allocatable, dimension(:) :: irs,irf,ics,icf
      integer :: ic,nc,ici,ice,ndof,rkp2e

      ndof=U%D()
      nc=U%N(d)

      write(*,*)
      write(*,*) '*** HGOrthoNorm1() ***'
      write(*,*)

      write(*,*) 'Original U:'
      call U%print()

!     Copy one col of U -> U1 for mode d, all cols for other modes
      write(*,*) 'Copy U -> U1 (1st col)'
      write(*,*)
      allocate(irs(ndof),irf(ndof),ics(ndof),icf(ndof))
      irs(:)=1
      irf(:)=U%rows(:)
      ics(:)=1
      icf(:)=U%cols(:)
      icf(d)=1
      U1=ExtractCPsubmatrix(U,irs,irf,ics,icf)
!     Do same for V,Y,S1,S2, but only copy diagonal element for mode d
      irs(:)=1
      irf(:)=V%rows(:)
      ics(:)=1
      icf(:)=V%cols(:)
      irf(d)=1
      icf(d)=1
      V1=ExtractCPsubmatrix(V,irs,irf,ics,icf)
      Y1=ExtractCPsubmatrix(Y,irs,irf,ics,icf)
      S1=ExtractCPsubmatrix(S,irs,irf,ics,icf)
      S21=ExtractCPsubmatrix(S2,irs,irf,ics,icf)
!      U1=CopyCP(U)
!      V1=CopyCP(V)
!      Y1=CopyCP(Y)
!      S1=CopyCP(S)
!      S21=CopyCP(S2)

!     Do also for P1 and Pr, which have the same dimensions
      irs(:)=1
      irf(:)=P1%rows(:)
      ics(:)=1
      icf(:)=P2%cols(:)
      irf(d)=1
      P11=ExtractCPsubmatrix(P1,irs,irf,ics,icf)
      Pr1=ExtractCPsubmatrix(Pr,irs,irf,ics,icf)

      UN=CopyCP(U)
      UN%coef(:)=1.d0
      rkp2e=U1%R()*Pr%R()

      DO ic=1,nc
!        Extract the ic-th col of mode d from U -> U1; zero rest of U1
         ici=U%ibas(d)+(ic-1)*U%M(d)
         ice=ici+U%M(d)-1
         U1%base(U1%ibas(d):U1%fbas(d),:)=U%base(ici:ice,:)
!         U1%base(U1%ibas(d):U1%fbas(d),:)=0.d0
!         U1%base(ici:ice,:)=U%base(ici:ice,:)
         U1%coef(:)=U%coef(:)

!        Extract (ic,ic) element (mode d) from V -> V1; zero rest of V1
         ici=V%ibas(d)+(ic-1)*(V%M(d)+1)
         V1%base(V1%ibas(d):V1%fbas(d),:)=V%base(ici:ici,:)
!         V1%base(V1%ibas(d):V1%fbas(d),:)=0.d0
!         V1%base(ici:ici,:)=V%base(ici:ici,:)
         V1%coef(:)=V%coef(:)

!        Extract (ic,ic) element (mode d) from Y -> Y1; zero rest of Y1
         ici=Y%ibas(d)+(ic-1)*(Y%M(d)+1)
         Y1%base(Y1%ibas(d):Y1%fbas(d),:)=Y%base(ici:ici,:)
!         Y1%base(Y1%ibas(d):Y1%fbas(d),:)=0.d0
!         Y1%base(ici:ici,:)=Y%base(ici:ici,:)
         Y1%coef(:)=Y%coef(:)

!        Extract (ic,ic) element (mode d) from S -> S1; zero rest of S1
         ici=S%ibas(d)+(ic-1)*(S%M(d)+1)
         S1%base(S1%ibas(d):S1%fbas(d),:)=S%base(ici:ici,:)
!         S1%base(S1%ibas(d):S1%fbas(d),:)=0.d0
!         S1%base(ici:ici,:)=S%base(ici:ici,:)
         S1%coef(:)=S%coef(:)

!        Extract (ic,ic) element (mode d) from S2 -> S21; 0 rest of S21
         S21%base(S21%ibas(d):S21%fbas(d),:)=S2%base(ici:ici,:)
!         S21%base(S21%ibas(d):S21%fbas(d),:)=0.d0
!         S21%base(ici:ici,:)=S2%base(ici:ici,:)
         S21%coef(:)=S2%coef(:)

         write(*,*)
         write(*,*) 'd,ic = ',d,ic,'; U1:'
         call U1%print()
         write(*,*)
         write(*,*) 'd,ic = ',d,ic,'; V1:'
         call V1%print()
         write(*,*)
         write(*,*) 'd,ic = ',d,ic,'; Y1:'
         call Y1%print()
         write(*,*)
         write(*,*) 'd,ic = ',d,ic,'; S1:'
         call S1%print()
         write(*,*)
         write(*,*) 'd,ic = ',d,ic,'; S21:'
         call S21%print()

!        Normalization
         call CPMatNorm1(Xyv,Xsy,Xus,U1,V1,Y1,S1,S21,nals,d)

!        Put normalized col ic into UN, with coefs on mode d for UN 
!        (cols have different coefs), then renormalize U1 for mode d.
         call MultOutCoef(U1,d)
         ici=U%ibas(d)+(ic-1)*U%M(d)
         ice=ici+U%M(d)-1
         UN%base(ici:ice,:)=U1%base(U1%ibas(d):U1%fbas(d),:)
!         UN%base(ici:ice,:)=U1%base(ici:ice,:)
         call NORMBASE1(U1,d,.TRUE.)

!        Exit upon reaching last col since nothing left to project out
         IF (ic.eq.nc) EXIT

!         call AbortWithError('Done here')

!        Project col ic out of other cols
!        V = [I - U1*U1^T]*U, using ic-th block of U

!        1st step: P1 = U1^T*U
!         call CPMM(U1,0,0.d0,.TRUE.,U,0,0.d0,.FALSE.,P1,d)
         call CPMM(U1,0,0.d0,.TRUE.,U,0,0.d0,.FALSE.,P11,d)

!        1st rank-reduction: Pr <- P1
!         call SolveLS(Xpp,Pr,P1,d)
         call SolveLS(Xpp,Pr1,P11,d)

!        2nd step: P2 = -U1*Pr + U
!         call CPMM(U1,0,0.d0,.FALSE.,&
!                   Pr,0,0.d0,.FALSE.,P2,d)
         call CPMM(U1,0,0.d0,.FALSE.,&
                   Pr1,0,0.d0,.FALSE.,P2,d)
         IF (d.eq.1) call VecSignChange(P2,1,rkp2e)
         P2%coef(rkp2e+1:P2%R())=U%coef(:)
         P2%base(P2%ibas(d):P2%fbas(d),rkp2e+1:P2%R())=&
         U%base(U%ibas(d):U%fbas(d),:)

!        2nd rank-reduction: U <- P2
         call SolveLS(Xup,U,P2,d)
      ENDDO

      call NORMBASE1(UN,d,.TRUE.)
      call ReplaceVwithW(U,UN)
      call FlushCP(U1)
      call FlushCP(V1)
      call FlushCP(Y1)
      call FlushCP(S1)
      call FlushCP(S21)
      call FlushCP(P11)
      call FlushCP(Pr1)
      deallocate(irs,irf,ics,icf)

      write(*,*)
      write(*,*) '*** HGOrthoNorm1() done ***'
      write(*,*)

      end subroutine HGOrthoNorm1

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine CPMatNorm1(Xyv,Xsy,Xus,U,V,Y,S,S2,nals,d)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Normalizes CP-tensor U, mode d 
! (U,V,Y,S,S2 passed with *ONE* col for mode d)

      implicit none
      TYPE (ALS), INTENT(INOUT) :: Xyv,Xsy,Xus
      TYPE (CP), INTENT(INOUT) :: U,V,Y,S,S2
      TYPE (CP) :: Un
      integer, intent(in)  :: nals,d

      write(*,*)
      write(*,*) '*** CPMatNorm1() ***'
      write(*,*)

!     Compute full-rank tensor of vector self-products (V)
      call CPMM(U,0,0.d0,.TRUE.,U,0,0.d0,.FALSE.,V,d)
      call CPMatrixZeroOffDiag(V,d)

!     Solve for reduced-rank tensor of vector self-products (Y)
      call SolveLS(Xyv,Y,V,d)

!     Square root of reduced-rank tensor of vector self-products
      call CPsqrt1(Xsy,Y,S,S2,10*nals,d)

!     Solve S*Un^T = U^T for Un^T
      call CPMatrixTranspose(U)
      Un=CopyCP(U)
      call RecomputeNormalEquations(Xus,S,0,0.d0,U,d)
      call SolveLS(Xus,Un,U,d)

!     Transpose Un^T and replace U1 <- Un      
      call CPMatrixTranspose(Un)
      call ReplaceVwithW(U,Un)

      write(*,*)
      write(*,*) '*** CPMatNorm1() done ***'
      write(*,*)

      end subroutine CPMatNorm1

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine CPsqrt1(X,F,G,G2,nitn,d)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Computes square root of CP-vector F, and stores in G, mode d
! G is provided as an initial guess

      implicit none
      TYPE (ALS), INTENT(INOUT) :: X
      TYPE (CP), INTENT(IN)     :: F
      TYPE (CP), INTENT(INOUT)  :: G,G2
      TYPE (CP) :: G1
      integer, intent(in) :: nitn,d
      real*8, parameter :: thresh=8.d-8
      real*8, parameter :: delthresh=1.d-5
      integer :: itn,oscct
      logical :: testmode=.TRUE.
      real*8  :: fmag,oldconver,conver,del
      character(len=64) :: frmt

!      write(*,*) 'CPsqrt1(): X'
!      call X%show()
!      write(*,*) 'CPsqrt1(): Y'
!      call F%print()
!      write(*,*) 'CPsqrt1(): S'
!      call G%print()
!      write(*,*) 'CPsqrt1(): S2'
!      call G2%print()

      IF (testmode) THEN
         frmt='(A,I3,A,ES16.8)'
         write(*,*)
         write(*,*) "CPsqrt1() iterations..."
         fmag=sqrt(abs(PRODVV(F)))
         oldconver=calc_FmG(G2,F)/fmag
         write(*,frmt) 'itn ',0,': ||F - G**2||/||F|| = ',oldconver
         IF (abs(oldconver).lt.thresh) THEN
            write(*,*) 'CPsqrt1() iterations converged!'
!            call FlushCP(T)
            RETURN
         ENDIF
      ENDIF

      oscct=0

      G1=CopyCP(G)

      DO itn=1,nitn

!        Solve for G1, for mode d
!         write(*,*) "CPsqrt1(): recalc normal eqns"
         call RecomputeNormalEquations(X,G,0,0.d0,F,d)
!         write(*,*) 'ATA:'
!         call X%ATA%print()
!         write(*,*) 'ATG:'
!         call X%ATG%print()
!         write(*,*) 'B:'
!         call PrintMatrix(X%B)
!         write(*,*) 'P:'
!         call PrintMatrix(X%P)

!         write(*,*) "CPsqrt1(): solve"
         call SolveLS(X,G1,F,d)

!         write(*,*) 'G before update'
!         call G%print()
!         write(*,*) 'G1 before update'
!         call G1%print()

!        Update: G <- (G1 + G)/2 and copy G1 <- G, for mode d
!         write(*,*) "CPsqrt1(): updates"
         call MultOutCoef(G,d)
         call MultOutCoef(G1,d)
         G%base(G%ibas(d):G%fbas(d),:)=G%base(G%ibas(d):G%fbas(d),:)+&
         G1%base(G1%ibas(d):G1%fbas(d),:)
         call NORMBASE1(G,d,.TRUE.)
         call VecScalarMult(G,0.5d0)
         G1%base(G1%ibas(d):G1%fbas(d),:)=G%base(G%ibas(d):G%fbas(d),:)
         G1%coef(:)=G%coef(:)

!        Update G2 with the new G,G1
         call CPMM(G,0,0.d0,.FALSE.,G1,0,0.d0,.FALSE.,G2,d)

!         write(*,*) 'G after update'
!         call G%print()

         IF (testmode) THEN
            frmt='(A,I3,A,ES16.8,A,ES16.8)'
            conver=calc_FmG(G2,F)/fmag
            del=abs(conver-oldconver)/abs(conver)
            IF (conver.gt.oldconver) oscct=oscct+1
            write(*,frmt) 'itn ',itn,': ||F - G**2||/||F|| = ',conver,&
                          '; del = ',del
            IF (abs(conver).lt.thresh) THEN 
               write(*,*) 'CPsqrt1() iterations converged!'
               EXIT
            ENDIF
            IF (del.lt.delthresh) THEN 
               write(*,*) 'CPsqrt1(): exit due to small residual change'
               EXIT
            ENDIF
            IF (oscct.eq.2) THEN
               write(*,*) 'CPsqrt1(): exit due to oscillating residual'
               EXIT
            ENDIF
            oldconver=conver
         ENDIF

      ENDDO

      call FlushCP(G1)

      end subroutine CPsqrt1

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine CPsqrtD(F,G,nitn,nals)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Computes square root of CP-vector F, and stores in G. All modes, no
! diagonal extraction. G is provided as an initial guess

      implicit none
!      TYPE (ALS), INTENT(INOUT) :: X
      TYPE (CP), INTENT(IN)     :: F
      TYPE (CP), INTENT(INOUT)  :: G!,G2
      TYPE (CP) :: G1,T
      integer, intent(in) :: nitn,nals
      real*8, parameter :: thresh=8.d-8
      real*8, parameter :: delthresh=1.d-5
      integer :: itn,oscct
      logical :: conv,testmode=.TRUE.
      real*8  :: fmag,oldconver,conver,del
      character(len=64) :: frmt

      IF (testmode) THEN
         frmt='(A,I3,A,ES16.8)'
         write(*,*)
         write(*,*) "CPsqrtD() iterations..."
         fmag=sqrt(abs(PRODVV(F)))
         call CPMM(G,.FALSE.,G,.FALSE.,T) ! T = G**2
         oldconver=calc_FmG(T,F)/fmag
         write(*,frmt) 'itn ',0,': ||F - G**2||/||F|| = ',oldconver
!         call FlushCP(T)
         IF (abs(oldconver).lt.thresh) THEN
            write(*,*) 'CPsqrtD() iterations converged!'
            RETURN
         ENDIF
      ENDIF

      oscct=0

      DO itn=1,nitn
         G1=CopyCP(G)

!        Solve for new G
         call ALS_solve(G,G1,F,nals)

!        Update: G1 <- (G1 + G)/2
         call SUMVECVEC(G1,0.5d0,G,0.5d0)

!        Reduce rank of new G
         call ALS_reduce(G,G1,nals)

!        Clean up
         call FlushCP(G1)

         IF (testmode) THEN
            frmt='(A,I3,A,ES16.8,A,ES16.8)'
            call CPMM(G,.FALSE.,G,.FALSE.,T) ! T = G**2
            conver=calc_FmG(T,F)/fmag
            del=abs(conver-oldconver)/abs(conver)
            IF (conver.gt.oldconver) oscct=oscct+1
            write(*,frmt) 'itn ',itn,': ||F - G**2||/||F|| = ',conver,&
                          '; del = ',del
            call FlushCP(T)
            IF (abs(conver).lt.thresh) THEN 
               write(*,*) 'CPsqrtD() iterations converged!'
               EXIT
            ENDIF
            IF (del.lt.delthresh) THEN 
               write(*,*) 'CPsqrtD(): exit due to small residual change'
               EXIT
            ENDIF
            IF (oscct.eq.2) THEN
               write(*,*) 'CPsqrtD(): exit due to oscillating residual'
               EXIT
            ENDIF
            oldconver=conver
         ENDIF
      ENDDO

      end subroutine CPsqrtD

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      subroutine TestWeightedRedn(H,F,G,ishift,Eshift)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      implicit none
      TYPE (CP), INTENT(IN) :: H,F,G
      TYPE (CP) :: Ft,Wt,W,AF
      integer, intent(in) :: ishift
      real*8, intent(in)  :: Eshift
      integer, parameter  :: nals=100
      real*8, allocatable :: Fm(:,:),Gm(:,:),diff(:,:)
      integer, allocatable :: indx(:),inmx(:),ir(:),ic(:)
      real*8  :: norm,valf,valg
      integer :: d,ndof
      character(len=64) :: frmt,tag
      logical :: doredn=.TRUE.

      ndof=F%D()

!      Fm=CP2Matrix(F)
!      Gm=CP2Matrix(G)
!      ALLOCATE(diff(SIZE(Fm,1),SIZE(Fm,2)))
!      diff(:,:)=Fm(:,:)-Gm(:,:)

!     Index values for NextIndex
      allocate(indx(2*ndof),inmx(2*ndof),ir(ndof),ic(ndof))
      DO d=1,ndof
         inmx(2*d-1)=F%rows(d)
         inmx(2*d)=F%cols(d)
      ENDDO

      IF (doredn) THEN
         write(*,*)
         write(*,*) '*** Elementwise ||F-G|| (no weights) ***'
         write(*,*)
         write(tag,'(A)') 'Unweighted reduction: F <-G '
         Ft=CopyCP(F)
         call ALS_reduce(Ft,G,nals,tag)
      ELSE
         write(*,*)
         write(*,*) '*** Elementwise ||AF-G|| (no weights) ***'
         write(*,*)
         write(tag,'(A)') 'Unweighted Solve: AF = G for F '
         Ft=CopyCP(F)
         call ALS_solve(H,Ft,G,nals,ishift,Eshift,tag)
         call CPMM(H,ishift,Eshift,.FALSE.,Ft,0,0.d0,.FALSE.,AF)
      ENDIF

      write(frmt,'(A,I0,A)') '(',2*ndof,'(I0,X),3(f16.8,2X))'
      norm=0.d0
      indx(:)=1
      DO
         DO d=1,ndof
            ir(d)=indx(2*d-1)
            ic(d)=indx(2*d)
         ENDDO
         IF (doredn) THEN
            valf=ExtractCPmatrixelement(Ft,ir,ic)
         ELSE
            valf=ExtractCPmatrixelement(AF,ir,ic)
         ENDIF
         valg=ExtractCPmatrixelement(G,ir,ic)
         norm=norm+(valf-valg)**2
         write(*,frmt) (ir(d),ic(d),d=1,ndof),valf,valg,valf-valg
         call NextIndex(indx,inmx)
         IF (ALL(indx.eq.1)) EXIT
      ENDDO
      norm=sqrt(norm)

      call FlushCP(AF)

      write(*,*) 'RMS diff = ',norm
      write(*,*)
      write(*,*) '*** done with elementwise ||F-G|| (no weights) ***'

      Wt=getweights(F)
      write(*,*) 'Here are weights, as a vector'
      call Wt%printvec()
      W=CPVtoDiagMatrix(Wt,Wt%sym)
      write(*,*) 'Here are weights, as diag matrix'
!      W=IdentityCPMatrix(F%rows,F%rows,F%sym)
      call W%print()

      IF (doredn) THEN
         write(*,*)
         write(*,*) '*** Elementwise ||F-G|| (weighted) ***'
         write(*,*)
         write(tag,'(A)') 'Weighted reduction: F <-G '
         Ft=CopyCP(F)
         call ALS_reduce(Ft,G,W,nals,tag)
      ELSE
         write(*,*)
         write(*,*) '*** Elementwise ||AF-G|| (weighted) ***'
         write(*,*)
         write(tag,'(A)') 'Weighted solve: AF = G for F'
         Ft=CopyCP(F)
         call ALS_solve(H,Ft,G,W,nals,ishift,Eshift,tag) 
         call CPMM(H,ishift,Eshift,.FALSE.,Ft,0,0.d0,.FALSE.,AF)
      ENDIF

      write(frmt,'(A,I0,A)') '(',2*ndof,'(I0,X),3(f16.8,2X))'
      norm=0.d0
      indx(:)=1
      DO
         DO d=1,ndof
            ir(d)=indx(2*d-1)
            ic(d)=indx(2*d)
         ENDDO
         IF (doredn) THEN
            valf=ExtractCPmatrixelement(Ft,ir,ic)
         ELSE
            valf=ExtractCPmatrixelement(AF,ir,ic)
         ENDIF
         valg=ExtractCPmatrixelement(G,ir,ic)
         norm=norm+(valf-valg)**2
         write(*,frmt) (ir(d),ic(d),d=1,ndof),valf,valg,valf-valg
         call NextIndex(indx,inmx)
         IF (ALL(indx.eq.1)) EXIT
      ENDDO
      norm=sqrt(norm)

      call FlushCP(AF)

      write(*,*) 'RMS diff = ',norm
      write(*,*)
      write(*,*) '*** done with elementwise ||F-G|| (weighted) ***'

!      deallocate(Fm,Gm,diff)
      deallocate(indx,inmx,ir,ic)

      call AbortWithError("Done TestWeightedRedn()")

      end subroutine TestWeightedRedn

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      function getweights(U) result (W)

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      implicit none
      TYPE (CP) , intent(in) :: U
      TYPE (CP) :: W
      integer :: i,j,d,rk
!     real*8, parameter :: kb=0.69503476 ! kb in cm-1

      rk=1
!      rk=4
      W=NewCPvec(rk,U%rows)

      W%coef(:)=1.d0
      DO j=1,rk
         DO d=1,W%D()
            DO i=1,W%rows(d)
               IF (i.ne.j) THEN         
!                  W%base(W%ibas(d)+i-1,j)=1.0d-5
               ELSE
!                  W%base(W%ibas(d)+i-1,j)=1.d0
               ENDIF
            ENDDO
         ENDDO
      ENDDO

      DO d=1,W%D()
         DO i=1,W%rows(d)
            W%base(W%ibas(d)+i-1,1)=20.d0**(1-i)
!            W%base(W%ibas(d)+i-1,1)=20.d0**(i-W%rows(d))
         ENDDO
      ENDDO

      end function getweights

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
